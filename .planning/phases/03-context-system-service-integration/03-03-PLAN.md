---
phase: 03-context-system-service-integration
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/lib/services/ai/generation/NarrativeService.ts
  - src/lib/services/ai/generation/SuggestionsService.ts
  - src/lib/services/ai/generation/ActionChoicesService.ts
  - src/lib/services/ai/generation/ClassifierService.ts
autonomous: true

must_haves:
  truths:
    - "NarrativeService generates prompts through ContextBuilder.forStory() instead of systemBuilder.ts"
    - "SuggestionsService uses ContextBuilder.forStory() + ctx.add() + ctx.render('suggestions')"
    - "ActionChoicesService uses ContextBuilder.forStory() + ctx.add() + ctx.render('action-choices')"
    - "ClassifierService uses ContextBuilder.forStory() + ctx.add() + ctx.render('classifier')"
    - "None of these services import from '$lib/services/prompts' anymore"
  artifacts:
    - path: "src/lib/services/ai/generation/NarrativeService.ts"
      provides: "Narrative generation using ContextBuilder pipeline"
      contains: "ContextBuilder.forStory"
    - path: "src/lib/services/ai/generation/SuggestionsService.ts"
      provides: "Suggestions using ContextBuilder pipeline"
      contains: "ContextBuilder.forStory"
    - path: "src/lib/services/ai/generation/ActionChoicesService.ts"
      provides: "Action choices using ContextBuilder pipeline"
      contains: "ContextBuilder.forStory"
    - path: "src/lib/services/ai/generation/ClassifierService.ts"
      provides: "Classification using ContextBuilder pipeline"
      contains: "ContextBuilder.forStory"
  key_links:
    - from: "src/lib/services/ai/generation/NarrativeService.ts"
      to: "src/lib/services/context/context-builder.ts"
      via: "ContextBuilder.forStory() for prompt generation"
      pattern: "ContextBuilder\\.forStory"
    - from: "src/lib/services/ai/generation/SuggestionsService.ts"
      to: "src/lib/services/context/context-builder.ts"
      via: "ContextBuilder.forStory() + add() + render()"
      pattern: "ctx\\.render|ctx\\.add"
---

<objective>
Migrate the 4 core generation services (NarrativeService, SuggestionsService, ActionChoicesService, ClassifierService) from the old PromptService/MacroEngine to the new ContextBuilder pipeline.

Purpose: These are the primary story generation services. Migrating them proves the ContextBuilder pipeline works end-to-end and covers requirements SVC-02 through SVC-06.

Output: All 4 services use `ContextBuilder.forStory()` + `ctx.add()` + `ctx.render()` instead of `promptService.renderPrompt()` + `promptService.renderUserPrompt()`.
</objective>

<execution_context>
@C:/Users/Admin/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-context-system-service-integration/03-CONTEXT.md
@.planning/phases/03-context-system-service-integration/03-01-SUMMARY.md
@.planning/phases/03-context-system-service-integration/03-02-SUMMARY.md

# ContextBuilder (from Plan 01)
@src/lib/services/context/context-builder.ts
@src/lib/services/context/types.ts
@src/lib/services/context/index.ts

# Services to migrate
@src/lib/services/ai/generation/NarrativeService.ts
@src/lib/services/ai/generation/SuggestionsService.ts
@src/lib/services/ai/generation/ActionChoicesService.ts
@src/lib/services/ai/generation/ClassifierService.ts

# SystemBuilder (NarrativeService dependency being replaced)
@src/lib/services/ai/prompts/systemBuilder.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate NarrativeService and remove systemBuilder dependency</name>
  <files>
    src/lib/services/ai/generation/NarrativeService.ts
  </files>
  <action>
Rewrite NarrativeService to use ContextBuilder instead of systemBuilder.ts:

**Current flow:**
1. Extract mode/pov/tense from story
2. Call `buildSystemPrompt(worldState, options)` which manually assembles the prompt with world state blocks, chapter summaries, style review injection
3. Call `buildPrimingMessage()` for the user prompt opening
4. Call `buildUserPrompt()` to format entries
5. Pass system + prompt to streamNarrative/generateNarrative

**New flow:**
1. Create `ctx = await ContextBuilder.forStory(storyId)` -- auto-populates mode, pov, tense, genre, protagonistName, etc. from story
2. Add runtime data via `ctx.add()`:
   - `tieredContextBlock`: The world state context block (from the existing ContextBuilder in generation/)
   - `retrievedChapterContext`: Memory chapter context string
   - `chapterSummaries`: Formatted chapter summaries block -- NarrativeService calls `buildChapterSummariesBlock(chapters, timelineFillResult)` (keep this function, move from systemBuilder into NarrativeService or a shared utility) and passes the resulting string
   - `styleGuidance`: Formatted style review block -- NarrativeService calls `StyleReviewerService.formatForPromptInjection(styleReview)` and passes the resulting string
   - `visualProseMode`, `inlineImageMode`: Boolean flags from story settings
   - `storyTime`: Already auto-populated by forStory, but could be overridden
3. Render: `const { system, user: primingUser } = await ctx.render('narrative')` -- or render('adventure') / render('creative-writing') depending on mode. The template already contains conditional logic per Plan 02.
4. Build the user prompt from entries (keep the existing `buildUserPrompt()` private method -- this is entry formatting, not template rendering)
5. Pass system prompt + priming + user prompt to streamNarrative/generateNarrative

**Key changes:**
- Remove import of `buildSystemPrompt`, `buildPrimingMessage` from systemBuilder
- Remove import of `promptService` from prompts
- Add import of `ContextBuilder` from context module
- The NarrativeService needs a storyId parameter (or story object). Adjust method signatures to accept storyId.
- Chapter summaries, style review, and world state context are still formatted by the service (these are data formatting tasks), then passed to ContextBuilder as runtime variables. The TEMPLATE uses these formatted blocks via `{{ tieredContextBlock }}`, `{{ chapterSummaries }}`, `{{ styleGuidance }}`.
- The priming message becomes part of the template (user content) or stays as a simple formatted string from the template.

**Important:** NarrativeService currently takes `worldState` and `story` objects directly. It needs a way to get storyId. The `story` parameter already has `story.id`. Use that.

Do NOT change the public API of NarrativeService methods (stream, generate) beyond what's minimally needed. Callers should work the same way.

If NarrativeService can't easily pass storyId (e.g., wizard usage where story doesn't exist yet), add a `forWizard` alternative path or let the caller pass story data directly. Check how NarrativeService is called -- it's called from the main generation flow after a story exists.
  </action>
  <verify>
Run `npx svelte-check` -- 0 errors. Verify NarrativeService imports ContextBuilder (not promptService or systemBuilder). Verify stream() and generate() methods use ContextBuilder.forStory(). Grep for `promptService` in NarrativeService -- should not be found.
  </verify>
  <done>
NarrativeService uses ContextBuilder.forStory() for all prompt generation. No imports from '$lib/services/prompts' or systemBuilder. Stream and generate methods work through the unified pipeline. Runtime data (world state, chapters, style review) added via ctx.add() as pre-formatted strings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate SuggestionsService, ActionChoicesService, and ClassifierService</name>
  <files>
    src/lib/services/ai/generation/SuggestionsService.ts
    src/lib/services/ai/generation/ActionChoicesService.ts
    src/lib/services/ai/generation/ClassifierService.ts
  </files>
  <action>
Migrate all 3 services following the same pattern:

**For each service:**
1. Remove `import { promptService, type PromptContext } from '$lib/services/prompts'`
2. Add `import { ContextBuilder } from '$lib/services/context'`
3. Replace the prompt generation pattern:

**Old pattern (all 3 services follow this):**
```typescript
const context: PromptContext = { mode, pov, tense, protagonistName }
const system = promptService.renderPrompt('template-id', context)
const prompt = promptService.renderUserPrompt('template-id', context, { runtimeVar1, runtimeVar2 })
```

**New pattern:**
```typescript
const ctx = await ContextBuilder.forStory(storyId)
ctx.add({ runtimeVar1, runtimeVar2 })
const { system, user: prompt } = await ctx.render('template-id')
```

**SuggestionsService specifics:**
- Currently receives `promptContext?: PromptContext` parameter. Replace with `storyId: string` parameter.
- Runtime variables to add: `recentContent`, `activeThreads`, `genre` (formatted string), `lorebookContext`
- Template: 'suggestions'
- The service still formats the runtime data (building recentContent string from entries, formatting threads, building lorebook context). That stays. Just the rendering changes.

**ActionChoicesService specifics:**
- Currently receives an `ActionChoicesContext` object with story data. Need storyId -- get from context or add parameter.
- Runtime variables to add: `narrativeResponse`, `recentContext`, `currentLocation`, `npcsPresent`, `inventory`, `activeQuests`, `lorebookContext`, `protagonistDescription`, `styleGuidance`, `povInstruction`, `lengthInstruction`
- Template: 'action-choices'
- The data formatting (building formatted strings from objects) stays in the service.

**ClassifierService specifics:**
- Currently receives `ClassificationContext` with `context.story.id` for storyId.
- The service keeps its existing data formatting methods: `formatExistingCharacters()`, `formatExistingBeats()`, `buildChatHistoryBlock()`, `formatVisualDescriptors()`. These produce formatted strings that are passed to ContextBuilder as runtime variables.
- Runtime variables to add via `ctx.add()` -- all 16 explicitly enumerated:
  - `genre`: Formatted genre string from `context.story.genre ? 'Genre: ' + context.story.genre : ''`
  - `mode`: Story mode string (`context.story.mode ?? 'adventure'`)
  - `entityCounts`: Formatted count string, e.g. `"5 characters, 3 locations, 2 items"`
  - `currentTimeInfo`: Formatted time string from currentStoryTime, e.g. `"Current story time: Year 1, Day 3, 08:30"`
  - `chatHistoryBlock`: Output of `this.buildChatHistoryBlock(visibleEntries, currentStoryTime)` -- formatted recent chat history with [ACTION]/[NARRATIVE] prefixes
  - `inputLabel`: `'Author Direction'` when mode is creative-writing, `'Player Action'` when adventure
  - `userAction`: Raw `context.userAction` string
  - `narrativeResponse`: Raw `context.narrativeResponse` string
  - `existingCharacters`: Output of `this.formatExistingCharacters(context.existingCharacters)` -- formatted list with names, relationships, status, visual descriptors
  - `existingLocations`: `context.existingLocations.map(l => l.name).join(', ') || '(none)'`
  - `existingItems`: `context.existingItems.map(i => i.name).join(', ') || '(none)'`
  - `existingBeats`: Output of `this.formatExistingBeats(context.existingStoryBeats)` -- formatted active/pending beats with titles, status, descriptions
  - `storyBeatTypes`: Static string `'milestone, quest, revelation, event, plot_point'`
  - `itemLocationOptions`: Static string `'inventory, worn, ground, or specific location name'`
  - `defaultItemLocation`: Static string `'inventory'`
  - `sceneLocationDesc`: Static string `'Name of current location if identifiable, null otherwise'`
- Template: 'classifier'

**Important for all 3:** The methods become async (or more async). ctx.render() is async. Make sure the Promise chain is correct. These services already return Promises, so this should be straightforward.

**Signature changes:** Each service method needs access to storyId. Check how each is called from the upstream code (e.g., generation orchestrator) and determine the least disruptive way to pass it. Options:
- Add storyId parameter to the method
- Add storyId to the existing context/options object
- Store storyId on the service instance
Choose the cleanest approach per service.
  </action>
  <verify>
Run `npx svelte-check` -- 0 errors. For each service, grep for `promptService` -- should not be found. Grep for `ContextBuilder.forStory` -- should be found in each. Verify all 3 services compile cleanly. For ClassifierService specifically, verify all 16 runtime variables (genre, mode, entityCounts, currentTimeInfo, chatHistoryBlock, inputLabel, userAction, narrativeResponse, existingCharacters, existingLocations, existingItems, existingBeats, storyBeatTypes, itemLocationOptions, defaultItemLocation, sceneLocationDesc) are passed via ctx.add().
  </verify>
  <done>
SuggestionsService, ActionChoicesService, and ClassifierService all use ContextBuilder.forStory() + ctx.add() + ctx.render(). No imports from '$lib/services/prompts'. Data formatting logic preserved in each service. ClassifierService passes all 16 runtime variables explicitly. Renders through unified pipeline.
  </done>
</task>

</tasks>

<verification>
- `npx svelte-check` passes with 0 errors
- 4 services migrated: NarrativeService, SuggestionsService, ActionChoicesService, ClassifierService
- No service imports from '$lib/services/prompts'
- All services use ContextBuilder.forStory() pattern
- systemBuilder.ts is no longer imported by NarrativeService
- ClassifierService passes all 16 runtime variables explicitly via ctx.add()
- Requirements covered: SVC-02, SVC-03, SVC-04, SVC-05, SVC-06
</verification>

<success_criteria>
- NarrativeService uses ContextBuilder instead of systemBuilder manual assembly
- SuggestionsService, ActionChoicesService, ClassifierService use ContextBuilder
- All 4 services render via ctx.render() returning { system, user }
- TypeScript compilation passes
- No references to old promptService in these 4 files
- ClassifierService runtime variables fully enumerated and passed
</success_criteria>

<output>
After completion, create `.planning/phases/03-context-system-service-integration/03-03-SUMMARY.md`
</output>
