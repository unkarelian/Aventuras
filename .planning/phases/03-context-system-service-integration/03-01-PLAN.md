---
phase: 03-context-system-service-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/services/context/types.ts
  - src/lib/services/context/runtime-variables.ts
  - src/lib/services/context/context-builder.ts
  - src/lib/services/context/index.ts
autonomous: true

must_haves:
  truths:
    - "ContextBuilder.forStory(storyId) loads story settings and auto-populates system variables into flat context"
    - "ContextBuilder.forWizard(wizardData, step) creates progressive context with step-appropriate variables"
    - "ctx.add({ key: value }) merges runtime data into flat context and returns this for chaining"
    - "ctx.render(templateId) returns { system: string, user: string } from a single call"
    - "Runtime variable definitions are registered once at module load, not per-request"
  artifacts:
    - path: "src/lib/services/context/types.ts"
      provides: "Type definitions for ContextBuilder, RenderResult, WizardStep enum"
      exports: ["RenderResult", "WizardStep", "ContextBuilderConfig"]
    - path: "src/lib/services/context/runtime-variables.ts"
      provides: "Runtime variable definitions catalog"
      exports: ["RUNTIME_VARIABLES", "getAvailableVariables"]
    - path: "src/lib/services/context/context-builder.ts"
      provides: "ContextBuilder class with fluent builder API"
      exports: ["ContextBuilder"]
    - path: "src/lib/services/context/index.ts"
      provides: "Public API barrel for context module"
      exports: ["ContextBuilder", "RUNTIME_VARIABLES"]
  key_links:
    - from: "src/lib/services/context/context-builder.ts"
      to: "src/lib/services/templates/engine.ts"
      via: "templateEngine.render() for Liquid rendering"
      pattern: "templateEngine\\.render"
    - from: "src/lib/services/context/context-builder.ts"
      to: "src/lib/services/packs/pack-service.ts"
      via: "packService.getTemplate() for template content"
      pattern: "packService|database\\."
    - from: "src/lib/services/context/context-builder.ts"
      to: "src/lib/services/database.ts"
      via: "database for story loading and pack template retrieval"
      pattern: "database\\."
---

<objective>
Create the ContextBuilder foundation -- types, runtime variable registry, and the core ContextBuilder class with fluent builder API.

Purpose: This is the central piece of Phase 3. Every service will use ContextBuilder to render prompts. It replaces the two-phase expansion (MacroEngine + placeholder injection) with a single LiquidJS render pass over a flat context object.

Output: `src/lib/services/context/` module with ContextBuilder class, types, runtime variable registry, and public API barrel.
</objective>

<execution_context>
@C:/Users/Admin/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-context-system-service-integration/03-CONTEXT.md
@.planning/phases/03-context-system-service-integration/03-RESEARCH.md

# Phase 1 artifacts (template engine this builds on)
@src/lib/services/templates/engine.ts
@src/lib/services/templates/variables.ts
@src/lib/services/templates/types.ts
@src/lib/services/templates/index.ts

# Phase 2 artifacts (pack service this integrates with)
@src/lib/services/packs/pack-service.ts
@src/lib/services/packs/types.ts
@src/lib/services/packs/index.ts

# Current prompt system (to understand what we're replacing)
@src/lib/services/prompts/types.ts
@src/lib/services/prompts/index.ts

# Database service (for story loading)
@src/lib/services/database.ts

# Existing services (to understand what runtime variables they need)
@src/lib/services/ai/generation/SuggestionsService.ts
@src/lib/services/ai/generation/ActionChoicesService.ts
@src/lib/services/ai/generation/ClassifierService.ts
@src/lib/services/ai/generation/NarrativeService.ts
@src/lib/services/ai/generation/MemoryService.ts
@src/lib/services/ai/generation/StyleReviewerService.ts
@src/lib/services/ai/prompts/systemBuilder.ts
@src/lib/services/ai/wizard/ScenarioService.ts
@src/lib/services/ai/utils/TranslationService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ContextBuilder types and runtime variable registry</name>
  <files>
    src/lib/services/context/types.ts
    src/lib/services/context/runtime-variables.ts
  </files>
  <action>
Create `src/lib/services/context/types.ts` with:

1. `RenderResult` interface: `{ system: string, user: string }` -- the return type of ctx.render()
2. `WizardStep` enum with all wizard steps (pack-selection, setting-creation, writing-style, character-creation, supporting-characters, opening-generation -- roughly matching the existing wizard flow). Each step maps to an integer for comparison.
3. `ContextBuilderConfig` interface for optional configuration (packId override, etc.)
4. `RuntimeVariableDefinition` interface: `{ name: string, description: string, category: 'runtime', availableFrom?: WizardStep }` -- extends the concept from Phase 1 variableRegistry
5. `ExternalTemplateIds` const array listing the 6 external template IDs: `image-style-soft-anime`, `image-style-semi-realistic`, `image-style-photorealistic`, `interactive-lorebook`, `lorebook-classifier`, `vault-character-import`

Create `src/lib/services/context/runtime-variables.ts` with:

1. `RUNTIME_VARIABLES` array of `RuntimeVariableDefinition` objects. Analyze all existing services to catalog every runtime variable they inject. Key variables include:
   - From SuggestionsService: `recentContent`, `activeThreads`, `genre` (as formatted string), `lorebookContext`
   - From ActionChoicesService: `narrativeResponse`, `recentContext`, `currentLocation`, `npcsPresent`, `inventory`, `activeQuests`, `lorebookContext`, `protagonistDescription`, `styleGuidance`, `povInstruction`, `lengthInstruction`
   - From ClassifierService: `genre`, `mode`, `entityCounts`, `currentTimeInfo`, `chatHistoryBlock`, `inputLabel`, `userAction`, `narrativeResponse`, `existingCharacters`, `existingLocations`, `existingItems`, `existingBeats`, `storyBeatTypes`, `itemLocationOptions`, `defaultItemLocation`, `sceneLocationDesc`
   - From MemoryService: `chapterContent`, `previousContext`, `messagesInRange`, `firstValidId`, `lastValidId`, `userInput`, `recentContext`, `chapterSummaries`, `maxChaptersPerRetrieval`
   - From StyleReviewerService: `passageCount`, `passages`
   - From NarrativeService/systemBuilder: `tieredContextBlock`, `retrievedContext`, `storyTime`, `chapterSummaries`, `styleGuidance` (formatted style review)
   - From ScenarioService (wizard): `genreLabel`, `seed`, `lorebookContext`, `customInstruction`, `settingName`, `settingDescription`, `currentSetting`, `characterName`, `characterDescription`, `characterBackground`, `settingContext`, `currentCharacter`, `count`, `protagonistDescription`, `toneInstruction`, `settingInstruction`, `povInstruction`, `outputFormat`, various opening-related vars
   - From TranslationService: `targetLanguage`, `sourceLanguage`, `content`, `elementsJson`, `suggestionsJson`, `choicesJson`
   - From lorebook/image/retrieval services: `recentContent`, `userInput`, `entrySummaries`, etc. (check actual files during implementation)

2. `getAvailableVariables(step?: WizardStep)` function that returns variables available at a given wizard step. All runtime variables are always available (services control when they call). System variables have step availability from the Phase 1 variableRegistry. If no step provided, return all.

Follow codebase conventions: no semicolons, single quotes, PascalCase types, camelCase variables.
  </action>
  <verify>
Run `npx svelte-check` -- 0 errors. Verify types.ts exports RenderResult, WizardStep, ExternalTemplateIds. Verify runtime-variables.ts exports RUNTIME_VARIABLES array with 30+ entries and getAvailableVariables function.
  </verify>
  <done>
types.ts defines RenderResult, WizardStep, ExternalTemplateIds, RuntimeVariableDefinition, ContextBuilderConfig. runtime-variables.ts catalogs all runtime variables from all services and exports getAvailableVariables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ContextBuilder class and public API barrel</name>
  <files>
    src/lib/services/context/context-builder.ts
    src/lib/services/context/index.ts
  </files>
  <action>
Create `src/lib/services/context/context-builder.ts` implementing the ContextBuilder class per user decisions:

**API (locked decisions):**
```
const ctx = ContextBuilder.forStory(storyId)
ctx.add({ recentContent, activeQuests })
const { system, user } = ctx.render('suggestions')
```

**Implementation details:**

1. `static async forStory(storyId: string): Promise<ContextBuilder>` -- Creates a new ContextBuilder instance:
   - Loads story from database (database.getStoryById or equivalent -- check database.ts for the right method)
   - Auto-populates system variables from story: `mode`, `pov`, `tense`, `genre`, `protagonistName` (from protagonist character), `currentLocation`, `storyTime` (formatted), `settingDescription`, `tone`, `themes` (joined string), plus `targetLanguage`/`sourceLanguage` from story.translationSettings if present
   - Loads active pack ID from story (database.getStoryPackId)
   - Loads custom variable values from the active pack's variables (database.getPackVariables) and adds their default values to context
   - All variables go into a single flat `Record<string, any>` context object
   - Returns the builder instance (note: this is async because of DB reads)

2. `static forWizard(wizardData: Record<string, any>, step: number): ContextBuilder` -- Creates wizard context:
   - Populates context from wizardData progressively based on step number
   - Early steps have fewer variables (e.g., step 2 has genre but no protagonistName)
   - Uses WizardStep enum for step boundaries
   - Returns synchronously (wizard data is already in memory)

3. `add(data: Record<string, any>): this` -- Merges runtime data into context using Object.assign. Returns `this` for chaining.

4. `async render(templateId: string): Promise<RenderResult>` -- Renders a template:
   - Check if templateId is in ExternalTemplateIds -- if so, return raw content without Liquid rendering (external template bypass per user decision)
   - Load template content from pack (using packId stored during forStory/forWizard)
   - Get both system content (templateId) and user content (templateId + '-user' suffix) from database
   - Render both through templateEngine.render() with the flat context
   - Return `{ system, user }`
   - Handle missing templates gracefully (return empty strings, log warning)

5. `getContext(): Record<string, any>` -- Returns current context (useful for debugging/logging)

**Key architectural decisions (Claude's discretion):**
- ContextBuilder is NOT a singleton -- instantiate per-render via static factory methods
- Store packId internally (set during forStory from story's pack assignment, or default pack)
- For forWizard, use default pack unless wizardData includes a packId
- Use `templateEngine` singleton from Phase 1 for rendering
- Use `database` singleton for DB access
- Use `packService` for template retrieval where appropriate
- Missing runtime variables render as empty string (LiquidJS default with strictVariables: false)
- Add DEBUG logging via createLogger('ContextBuilder')

Create `src/lib/services/context/index.ts` barrel file exporting:
- `ContextBuilder` class
- All types from types.ts
- `RUNTIME_VARIABLES` and `getAvailableVariables` from runtime-variables.ts
- Follow the same barrel pattern as templates/index.ts and packs/index.ts
  </action>
  <verify>
Run `npx svelte-check` -- 0 errors. Verify context-builder.ts exports ContextBuilder class with static forStory, forWizard methods, add method returning `this`, render method returning Promise of RenderResult. Verify index.ts re-exports everything needed.
  </verify>
  <done>
ContextBuilder class implements the full fluent builder API: `forStory(storyId)` auto-populates system + custom variables, `forWizard(data, step)` creates progressive context, `add()` merges runtime data, `render()` returns `{ system, user }`. Public API barrel exports everything. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
- `npx svelte-check` passes with 0 errors, 0 warnings
- `src/lib/services/context/` directory contains types.ts, runtime-variables.ts, context-builder.ts, index.ts
- ContextBuilder.forStory is async and loads from database
- ContextBuilder.forWizard is synchronous with progressive context
- ctx.add() returns `this` for method chaining
- ctx.render() returns `{ system: string, user: string }`
- External templates bypass Liquid rendering
- Flat namespace: all variables accessible as `{{ variableName }}` directly
- No nesting by source (no `{{ story.mode }}` or `{{ runtime.recentContent }}`)
</verification>

<success_criteria>
- ContextBuilder class exists with forStory, forWizard, add, render API
- Runtime variable registry catalogs 30+ variables from all services
- Types define RenderResult, WizardStep, ExternalTemplateIds
- Public barrel exports complete API
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-context-system-service-integration/03-01-SUMMARY.md`
</output>
