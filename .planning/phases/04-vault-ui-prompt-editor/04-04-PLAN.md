---
phase: 04-vault-ui-prompt-editor
plan: 04
type: execute
wave: 4
depends_on: ["04-03"]
files_modified:
  - src/lib/components/vault/prompts/TemplateEditor.svelte
  - src/lib/components/vault/prompts/VariablePalette.svelte
  - src/lib/components/vault/prompts/PromptPackEditor.svelte
autonomous: true

must_haves:
  truths:
    - "User can edit any template with syntax highlighting for Liquid syntax"
    - "Editor shows system prompt and user message as separate tabs when both exist"
    - "User can insert variables via a searchable command-palette popup"
    - "Editor shows real-time validation feedback below the editor"
    - "User can save changes to a template"
    - "User can discard unsaved changes"
    - "User can reset a template to its default content"
    - "Editor supports undo/redo"
    - "Unsaved changes warning appears when switching templates"
  artifacts:
    - path: "src/lib/components/vault/prompts/TemplateEditor.svelte"
      provides: "CodeMirror editor with Liquid highlighting, tabs, validation, save/discard/reset"
      contains: "svelte-codemirror-editor"
    - path: "src/lib/components/vault/prompts/VariablePalette.svelte"
      provides: "Searchable variable insertion command palette"
      contains: "Command"
  key_links:
    - from: "src/lib/components/vault/prompts/TemplateEditor.svelte"
      to: "svelte-codemirror-editor"
      via: "CodeMirror component import"
      pattern: "import CodeMirror from 'svelte-codemirror-editor'"
    - from: "src/lib/components/vault/prompts/TemplateEditor.svelte"
      to: "@codemirror/lang-liquid"
      via: "Liquid language support"
      pattern: "import.*liquid.*@codemirror/lang-liquid"
    - from: "src/lib/components/vault/prompts/TemplateEditor.svelte"
      to: "src/lib/services/templates/validator.ts"
      via: "validateTemplate for real-time validation"
      pattern: "validateTemplate"
    - from: "src/lib/components/vault/prompts/TemplateEditor.svelte"
      to: "src/lib/services/database.ts"
      via: "database.setPackTemplateContent for saving"
      pattern: "setPackTemplateContent"
    - from: "src/lib/components/vault/prompts/VariablePalette.svelte"
      to: "src/lib/services/templates/variables.ts"
      via: "variableRegistry for variable list"
      pattern: "variableRegistry"
---

<!-- EDT-04 USER DECISION OVERRIDE:
     Original EDT-04 required "inserting variables and conditionals" toolbar.
     User decision (CONTEXT.md): "No dedicated conditional insertion tool â€” users type
     conditionals manually." This plan implements variable insertion ONLY, per user decision.
     EDT-04 in REQUIREMENTS.md has been updated to reflect this. -->

<objective>
Build the CodeMirror-based template editor with Liquid syntax highlighting, system/user message tabs, variable insertion palette, real-time validation, save/discard/reset, undo/redo, and dirty tracking.

Purpose: This is the core editing experience -- where users actually modify templates. It must feel responsive, provide clear feedback on errors, and protect against accidental data loss.

Output: Fully functional template editor with all editing requirements satisfied.
</objective>

<execution_context>
@C:\Users\asvintheguy\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\asvintheguy\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-vault-ui-prompt-editor/04-CONTEXT.md
@.planning/phases/04-vault-ui-prompt-editor/04-RESEARCH.md
@.planning/phases/04-vault-ui-prompt-editor/04-03-SUMMARY.md
@src/lib/components/vault/prompts/PromptPackEditor.svelte
@src/lib/services/templates/variables.ts
@src/lib/services/templates/validator.ts
@src/lib/services/templates/engine.ts
@src/lib/services/packs/pack-service.ts
@src/lib/services/packs/types.ts
@src/lib/services/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VariablePalette component</name>
  <files>
    src/lib/components/vault/prompts/VariablePalette.svelte
  </files>
  <action>
Command-palette style popup for inserting variables at the cursor position. Per user decision: searchable, keyboard-friendly, categorized. Variable insertion ONLY -- no conditional insertion tool (per user decision, users type conditionals manually with syntax highlighting support).

Props:
```typescript
interface Props {
  customVariables: CustomVariable[]
  onInsert: (variableName: string) => void
}
```

Implementation:
1. Use shadcn Popover + Command components
2. Trigger is a button with a variable icon (e.g., `Braces` from lucide-svelte) and label "Insert Variable"
3. Command groups:
   - "System" -- from `variableRegistry.getByCategory('system')` -- show name and description
   - "Runtime" -- from `variableRegistry.getByCategory('runtime')` -- show name and description
   - "Custom" -- from `customVariables` prop -- show variableName and displayName
4. Each Command.Item: clicking calls `onInsert(variableName)` and closes the popover
5. Command.Input provides search across all variables
6. Variable names shown in monospace: `{{ variableName }}`
7. Command.Empty shows "No variable found."

Import `variableRegistry` from `$lib/services/templates/variables`. Import `CustomVariable` from `$lib/services/packs/types`.

Mobile considerations (EDT-12): Button has min 44px tap target. Popover uses bottom-aligned positioning on mobile for better reachability. All interactions are tap-friendly, no hover dependencies.
  </action>
  <verify>
1. `npm run check` passes
2. VariablePalette renders a button that opens a searchable command palette
3. All three variable categories appear as groups
4. Clicking a variable calls onInsert with the variable name
  </verify>
  <done>
- VariablePalette shows searchable, categorized variable list
- Clicking a variable fires onInsert callback
- Mobile-friendly with touch-sized targets
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TemplateEditor component</name>
  <files>
    src/lib/components/vault/prompts/TemplateEditor.svelte
  </files>
  <action>
The main editor component with CodeMirror, tabs, validation, and all editing controls.

Props:
```typescript
interface Props {
  packId: string
  templateId: string
  customVariables: CustomVariable[]
  onDirtyChange?: (dirty: boolean) => void
}
```

State:
```typescript
// Content management
let systemContent = $state('')      // Current system prompt content
let userContent = $state('')        // Current user message content
let originalSystem = $state('')     // Last saved system content
let originalUser = $state('')       // Last saved user content
let activeTab = $state<'system' | 'user'>('system')
let hasUserContent = $state(false)  // Whether this template has a user message

// Dirty tracking
let isSystemDirty = $derived(systemContent !== originalSystem)
let isUserDirty = $derived(userContent !== originalUser)
let isDirty = $derived(isSystemDirty || isUserDirty)

// Validation
let validationErrors = $state<ValidationError[]>([])
let validationTimer: ReturnType<typeof setTimeout>

// Editor view reference for variable insertion
let editorView = $state<EditorView | null>(null)
```

On mount / when templateId changes:
1. Load system template: `database.getPackTemplate(packId, templateId)` -- set systemContent and originalSystem
2. Load user template: `database.getPackTemplate(packId, templateId + '-user')` -- if exists, set userContent, originalUser, hasUserContent=true
3. Reset validation errors

CodeMirror setup:
```typescript
import CodeMirror from 'svelte-codemirror-editor'
import { liquid } from '@codemirror/lang-liquid'
import { EditorView, keymap } from '@codemirror/view'
import { defaultKeymap, history, historyKeymap, undo, redo } from '@codemirror/commands'
import type { Completion } from '@codemirror/autocomplete'
```

Build variable completions from variableRegistry + customVariables:
```typescript
const completions = $derived.by(() => {
  const result: Completion[] = []
  for (const v of variableRegistry.getAll()) {
    result.push({ label: v.name, type: 'variable', detail: v.category, info: v.description })
  }
  for (const v of customVariables) {
    result.push({ label: v.variableName, type: 'variable', detail: 'custom', info: v.displayName })
  }
  return result
})
```

Memoize the liquid language extension to avoid recreating on every render (per pitfall #1 from research):
```typescript
let cachedCompletionCount = $state(0)
let liquidLang = $state(liquid({}))

$effect(() => {
  if (completions.length !== cachedCompletionCount) {
    cachedCompletionCount = completions.length
    liquidLang = liquid({ variables: completions })
  }
})
```

Custom theme using app CSS variables:
```typescript
const editorTheme = EditorView.theme({
  '&': { height: '100%', fontSize: '14px' },
  '.cm-content': { fontFamily: 'var(--font-mono, monospace)', padding: '12px' },
  '.cm-gutters': { backgroundColor: 'var(--surface-50, #f8f8f8)', borderRight: '1px solid var(--border)' },
  '.cm-activeLine': { backgroundColor: 'var(--surface-100, #f0f0f0)' },
  '.cm-selectionBackground': { backgroundColor: 'var(--accent, #e0e0ff) !important' },
})
```

Extensions array (memoized):
```typescript
const extensions = [editorTheme, history(), keymap.of([...defaultKeymap, ...historyKeymap])]
```

Validation (debounced):
```typescript
import { validateTemplate } from '$lib/services/templates'

$effect(() => {
  // Re-validate when content changes
  const content = activeTab === 'system' ? systemContent : userContent
  clearTimeout(validationTimer)
  validationTimer = setTimeout(() => {
    const result = validateTemplate(content)
    validationErrors = result.errors
  }, 500)
})
```

Variable insertion function (called from VariablePalette's onInsert):
```typescript
function handleInsertVariable(variableName: string) {
  if (!editorView) return
  const insertion = `{{ ${variableName} }}`
  const cursor = editorView.state.selection.main.head
  editorView.dispatch({
    changes: { from: cursor, insert: insertion },
    selection: { anchor: cursor + insertion.length },
  })
  editorView.focus()
}
```

Access EditorView via svelte-codemirror-editor's callback. Check the wrapper's API -- it may expose the view via an `onready` or bind directive. If the wrapper exposes a `view` bindable, use `bind:view={editorView}`. Otherwise, use the `on:ready` event.

Save function:
```typescript
async function save() {
  if (isSystemDirty) {
    await database.setPackTemplateContent(packId, templateId, systemContent)
    originalSystem = systemContent
  }
  if (isUserDirty && hasUserContent) {
    await database.setPackTemplateContent(packId, `${templateId}-user`, userContent)
    originalUser = userContent
  }
}
```

Discard function:
```typescript
function discard() {
  systemContent = originalSystem
  userContent = originalUser
}
```

Reset function:
```typescript
async function resetToDefault() {
  if (activeTab === 'system') {
    const success = await packService.resetTemplate(packId, templateId)
    if (success) {
      const template = await database.getPackTemplate(packId, templateId)
      if (template) {
        systemContent = template.content
        originalSystem = template.content
      }
    }
  } else {
    const success = await packService.resetTemplate(packId, `${templateId}-user`)
    if (success) {
      const template = await database.getPackTemplate(packId, `${templateId}-user`)
      if (template) {
        userContent = template.content
        originalUser = template.content
      }
    }
  }
}
```

Export `save()` and `discard()` as public methods so PromptPackEditor can call them for the dirty guard.

Notify parent of dirty state changes:
```typescript
$effect(() => {
  onDirtyChange?.(isDirty)
})
```

Layout:
1. **Header area**: Template name (from PROMPT_TEMPLATES lookup by ID), dirty indicator (dot or bullet when dirty)
2. **Tabs** (if hasUserContent): "System Prompt" | "User Message" tabs using shadcn Tabs
3. **Toolbar**: Save button (disabled when not dirty), Discard button (disabled when not dirty), Reset to Default button, VariablePalette component
4. **CodeMirror editor**: Full height of remaining space. Shows systemContent or userContent based on activeTab. Use `bind:value` for the active content.
5. **Validation bar**: Below the editor. Shows validation errors if any. Each error shows: icon (warning/error), message, and line number if available. Use `text-sm text-destructive` styling. Hide bar when no errors.

IMPORTANT: When switching between system/user tabs, the CodeMirror value must update. Since `svelte-codemirror-editor` uses `bind:value`, switching the bound variable should work. But test that undo history is preserved per-tab (it likely resets -- this is acceptable).

Mobile considerations:
- Toolbar wraps to multiple rows on small screens
- Save/Discard/Reset use icon-only buttons on mobile
- VariablePalette uses bottom-aligned Popover or Drawer on mobile

EDT-12 compliance: All toolbar items are touch-friendly (min 44px tap targets), no hover-dependent interactions. Variable palette works via tap. Save/Discard/Reset accessible via buttons.
  </action>
  <verify>
1. `npm run check` passes
2. The CodeMirror editor renders with Liquid syntax highlighting
3. System/User tabs switch content correctly
4. Variable palette shows system, runtime, and custom variables
5. Validation errors appear below editor within 500ms of typing invalid syntax
6. Save persists to database, Discard reverts, Reset loads defaults
7. Undo/redo works via Ctrl+Z/Ctrl+Shift+Z
  </verify>
  <done>
- EDT-01: User can edit templates through in-app editor
- EDT-02: Liquid syntax highlighting via @codemirror/lang-liquid
- EDT-03: Bottom toolbar with variable insertion palette (mobile-friendly)
- EDT-04: Variable insertion only -- no conditional builder per user decision (users type conditionals manually)
- EDT-06: Real-time validation feedback (bar below editor)
- EDT-07: Save changes to template
- EDT-08: Discard unsaved changes
- EDT-09: Reset template to default
- EDT-11: Undo/redo via CodeMirror history
- EDT-12: Mobile-friendly, no hover-dependent interactions
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire TemplateEditor into PromptPackEditor with dirty guard</name>
  <files>src/lib/components/vault/prompts/PromptPackEditor.svelte</files>
  <action>
Update PromptPackEditor to:

1. Import TemplateEditor:
```typescript
import TemplateEditor from './TemplateEditor.svelte'
```

2. Replace the right panel placeholder with the actual TemplateEditor when a template is selected:
```svelte
{#if showVariables}
  <div class="flex-1 flex items-center justify-center text-muted-foreground">
    Variable Manager -- coming in Plan 05
  </div>
{:else if selectedTemplateId}
  <TemplateEditor
    packId={packId}
    templateId={selectedTemplateId}
    customVariables={fullPack?.variables ?? []}
    onDirtyChange={(dirty) => { isEditorDirty = dirty }}
  />
{:else}
  <div class="flex-1 flex items-center justify-center text-muted-foreground">
    Select a template to edit
  </div>
{/if}
```

3. Add dirty guard when switching templates:
```typescript
let isEditorDirty = $state(false)
let pendingTemplateId = $state<string | null>(null)
let showDirtyDialog = $state(false)

function handleSelectTemplate(templateId: string) {
  if (isEditorDirty) {
    pendingTemplateId = templateId
    showDirtyDialog = true
    return
  }
  selectedTemplateId = templateId
  showVariables = false
}
```

4. Add a confirmation dialog (shadcn Dialog or AlertDialog) for unsaved changes:
- "You have unsaved changes to this template. What would you like to do?"
- Three actions: "Save & Switch" (save then switch), "Discard & Switch" (discard then switch), "Cancel" (stay)
- On save & switch: need a way to trigger save on the TemplateEditor. Use a `saveRef` pattern or expose a save method. Simpler: just discard and switch, since the dialog gives the user the choice. Provide "Save" and "Discard" buttons. "Save" calls TemplateEditor's save (expose via bind or callback), then switches. "Discard" just switches.

Actually, simplest approach: pass `onBeforeSwitch` to TemplateEditor that returns a promise. Or, have PromptPackEditor manage the dirty dialog itself. Keep it simple:

- When dirty dialog shows with "Save & Switch": set a flag that triggers save in TemplateEditor, then after save completes, switch template.
- Simpler: Use a `saveRequested` prop or a bindable `triggerSave` function.

Simplest correct approach: TemplateEditor exposes a `save()` function via `bind:this` and a method, or use a `requestSave` callback pattern. Given Svelte 5, use `$bindable` with a ref:

Actually, simplest: TemplateEditor already has `onDirtyChange`. Add an `onSave` callback prop that PromptPackEditor can call. No -- TemplateEditor does the saving internally.

Best approach: Use Svelte's component binding. TemplateEditor exports a `save` function. PromptPackEditor uses `bind:this` to call it:

```svelte
<script>
let editorRef: TemplateEditor
</script>

<TemplateEditor bind:this={editorRef} ... />
```

Then in the dialog handler:
```typescript
async function handleSaveAndSwitch() {
  await editorRef.save()
  selectedTemplateId = pendingTemplateId
  pendingTemplateId = null
  showDirtyDialog = false
}

function handleDiscardAndSwitch() {
  editorRef.discard()
  selectedTemplateId = pendingTemplateId
  pendingTemplateId = null
  showDirtyDialog = false
}
```

For this to work, TemplateEditor must export `save()` and `discard()` as public methods. Add `export` keyword to those functions in TemplateEditor.

5. Similarly, add dirty guard when clicking Variables tab and when clicking Back to Packs.

6. Update the Back button handler:
```typescript
function handleClose() {
  if (isEditorDirty) {
    // Show dialog with "Save & Leave" / "Discard & Leave" / "Cancel"
    pendingAction = 'close'
    showDirtyDialog = true
    return
  }
  onClose()
}
```
  </action>
  <verify>
1. `npm run check` passes
2. Selecting a template shows the TemplateEditor in the right panel
3. Editing a template then clicking another template shows the dirty dialog
4. "Save & Switch" saves changes then switches, "Discard & Switch" reverts then switches
5. Back button warns about unsaved changes
  </verify>
  <done>
- Template selection shows CodeMirror editor in right panel
- Unsaved changes protected by confirmation dialog on template switch
- Unsaved changes protected on back navigation
- TemplateEditor save/discard functions accessible from parent
  </done>
</task>

</tasks>

<verification>
1. `npm run check` passes
2. CodeMirror renders with Liquid syntax highlighting for template content
3. System/User message tabs work correctly
4. Variable palette inserts `{{ variableName }}` at cursor
5. Validation errors display in bar below editor
6. Save/Discard/Reset all function correctly
7. Undo/Redo via keyboard shortcuts
8. Dirty guard prevents accidental data loss on template switch
</verification>

<success_criteria>
- EDT-01: Template editing through in-app CodeMirror editor
- EDT-02: Liquid syntax highlighting
- EDT-03: Variable insertion via command palette (mobile-friendly)
- EDT-04: Variable insertion only -- no conditional builder per user decision (CONTEXT.md: "No dedicated conditional insertion tool -- users type conditionals manually")
- EDT-06: Real-time validation feedback
- EDT-07: Save changes
- EDT-08: Discard changes
- EDT-09: Reset to default
- EDT-11: Undo/redo
- EDT-12: Mobile-friendly (touch targets, no hover dependencies)
- Dirty tracking prevents accidental data loss
</success_criteria>

<output>
After completion, create `.planning/phases/04-vault-ui-prompt-editor/04-04-SUMMARY.md`
</output>
