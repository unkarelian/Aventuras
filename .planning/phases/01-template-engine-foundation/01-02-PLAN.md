---
phase: 01-template-engine-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/services/templates/validator.ts
  - src/lib/services/templates/index.ts
autonomous: true

must_haves:
  truths:
    - "Syntax errors in templates produce clear, non-technical error messages with line numbers"
    - "References to unknown variables produce helpful error messages with similar name suggestions"
    - "References to unknown filters produce helpful error messages with similar filter suggestions"
    - "A valid template with all known variables returns { valid: true, errors: [] }"
    - "Validation can be called on each keystroke (stateless, no side effects)"
    - "The public API exports render(), validate(), and variable registry from a single import path"
    - "Services import only from '$lib/services/templates' -- never from liquidjs directly"
  artifacts:
    - path: "src/lib/services/templates/validator.ts"
      provides: "Template validation: syntax checking + variable reference checking + user-friendly error messages"
      exports: ["validateTemplate"]
    - path: "src/lib/services/templates/index.ts"
      provides: "Public API barrel: re-exports engine, validator, variables, types"
      exports: ["templateEngine", "validateTemplate", "variableRegistry"]
  key_links:
    - from: "src/lib/services/templates/validator.ts"
      to: "src/lib/services/templates/engine.ts"
      via: "uses templateEngine.parseTemplate() for syntax validation and templateEngine.extractVariableNames() for variable extraction"
      pattern: "templateEngine\\.parseTemplate|templateEngine\\.extractVariableNames"
    - from: "src/lib/services/templates/validator.ts"
      to: "src/lib/services/templates/variables.ts"
      via: "uses variableRegistry.has() and variableRegistry.getAllNames() to check variable references"
      pattern: "variableRegistry\\.has|variableRegistry\\.getAllNames"
    - from: "src/lib/services/templates/index.ts"
      to: "src/lib/services/templates/engine.ts"
      via: "re-exports templateEngine"
      pattern: "export.*templateEngine.*from.*engine"
    - from: "src/lib/services/templates/index.ts"
      to: "src/lib/services/templates/validator.ts"
      via: "re-exports validateTemplate"
      pattern: "export.*validateTemplate.*from.*validator"
    - from: "src/lib/services/templates/index.ts"
      to: "src/lib/services/templates/variables.ts"
      via: "re-exports variableRegistry"
      pattern: "export.*variableRegistry.*from.*variables"
---

<objective>
Build the template validation system and wire up the public API barrel file. Validation catches syntax errors and unknown variable/filter references at save time, producing clear error messages for non-technical users. The barrel file creates the single import point that all services will use.

Purpose: Validation is the core of the "validation-first philosophy" -- templates must pass full validation before they can be saved (user decision). The barrel file ensures no service ever imports LiquidJS directly. Together, these complete the Phase 1 engine: types, rendering, variables, validation, and a clean public API.

Output: validator.ts with validateTemplate() function producing user-friendly errors. index.ts barrel exporting the complete template engine API.
</objective>

<execution_context>
@C:/Users/Admin/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-template-engine-foundation/01-CONTEXT.md
@.planning/phases/01-template-engine-foundation/01-RESEARCH.md
@.planning/phases/01-template-engine-foundation/01-01-SUMMARY.md
@.planning/codebase/CONVENTIONS.md
@src/lib/services/templates/types.ts
@src/lib/services/templates/engine.ts
@src/lib/services/templates/variables.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create template validator with user-friendly error messages</name>
  <files>
    src/lib/services/templates/validator.ts
  </files>
  <action>
Create `src/lib/services/templates/validator.ts` that exports a `validateTemplate` function. This implements ENG-09 (unknown variable feedback) and supports the save-time validation blocking (user decision: "validation-first philosophy").

**Main export:**

```typescript
function validateTemplate(
  template: string,
  additionalVariables?: string[]
): ValidationResult
```

- `template`: the raw template string to validate
- `additionalVariables`: optional extra variable names to consider valid beyond what's in the registry. This supports custom variables from preset packs (Phase 2) and runtime variables that aren't in the base registry yet. When Phase 2 adds custom variables, they'll be passed here.
- Returns `ValidationResult` with `valid: boolean` and `errors: ValidationError[]`

**Validation steps (in order):**

1. **Syntax validation** -- Call `templateEngine.parseTemplate(template)`. If it fails, convert the LiquidJS error into a user-friendly `ValidationError` with type `'syntax'`. Apply error message simplification (see below). Return immediately on syntax error -- no point checking variables if syntax is broken.

2. **Variable reference validation** -- Call `templateEngine.extractVariableNames(template)` to get all referenced variables. For each variable name:
   - Check `variableRegistry.has(name)` -- if found, it's valid
   - Check if name is in `additionalVariables` array -- if found, it's valid
   - Otherwise, create a `ValidationError` with type `'unknown_variable'`, a user-friendly message, and a "did you mean?" suggestion

3. **Filter validation** -- Extract filter names from template using regex: `/\{\{[^}]*\|\s*(\w+)/g` to capture filter names after the pipe. Check against LiquidJS's known built-in filter list. For unknown filters, create `ValidationError` with type `'unknown_filter'` and "did you mean?" suggestion.

**Error message simplification (per research + user decision on non-technical users):**

Create a helper function `simplifyError(rawError: string): string` that transforms LiquidJS technical errors into plain language:

| LiquidJS Error Pattern | User-Friendly Message |
|---|---|
| `tag "..." not closed` or `"endif" not found` | `Missing closing tag for 'if' statement` |
| `unexpected token` | `Unexpected syntax near line N` |
| `unknown tag` | `Unknown command: '{tagname}'. Check your spelling.` |
| Parse errors with line/col info | Extract line/column numbers and include them |
| Default fallback | `Template syntax error: {simplified message}` |

**"Did you mean?" suggestions:**

Create a helper function `findSimilar(name: string, validNames: string[], maxDistance?: number): string | undefined` that uses Levenshtein distance (simple implementation, ~15 lines) to find the closest match. Return the closest match if distance <= 2 (or `maxDistance`), otherwise undefined.

Use this for both unknown variable and unknown filter suggestions:
- Unknown variable: `Variable '${name}' doesn't exist.${suggestion ? ` Did you mean '${suggestion}'?` : ' Check the available variables list.'}`
- Unknown filter: `Filter '${name}' doesn't exist.${suggestion ? ` Did you mean '${suggestion}'?` : ''}`

**Built-in filter list for validation:**

LiquidJS ships with 40+ filters. Create a `KNOWN_FILTERS` constant array listing them. Key ones: `abs`, `append`, `at_least`, `at_most`, `capitalize`, `ceil`, `compact`, `concat`, `date`, `default`, `divided_by`, `downcase`, `escape`, `escape_once`, `first`, `floor`, `join`, `json`, `last`, `lstrip`, `map`, `minus`, `modulo`, `newline_to_br`, `plus`, `prepend`, `remove`, `remove_first`, `replace`, `replace_first`, `reverse`, `round`, `rstrip`, `size`, `slice`, `sort`, `sort_natural`, `split`, `strip`, `strip_html`, `strip_newlines`, `times`, `truncate`, `truncatewords`, `uniq`, `upcase`, `url_decode`, `url_encode`, `where`. (Reference LiquidJS docs for complete list.)

**Important implementation notes:**
- This function must be stateless and side-effect-free -- it can be called on every keystroke in the editor (Phase 4)
- Do NOT throw errors -- always return a ValidationResult
- Import `templateEngine` from `./engine` and `variableRegistry` from `./variables`
- Import types from `./types`
- Use `createLogger` for debug logging
  </action>
  <verify>
1. `npx tsc --noEmit` passes with no errors
2. Read validator.ts and confirm:
   - `validateTemplate` function is exported
   - It calls `templateEngine.parseTemplate()` for syntax checking
   - It calls `templateEngine.extractVariableNames()` for variable extraction
   - It checks `variableRegistry.has()` for each variable
   - KNOWN_FILTERS array has 40+ entries
   - `findSimilar()` Levenshtein helper exists
   - `simplifyError()` error message transformation exists
   - Function returns ValidationResult, never throws
  </verify>
  <done>
validateTemplate() accepts a template string and optional additional variable names, returns ValidationResult with user-friendly errors. Catches syntax errors with plain-language messages, flags unknown variables with "did you mean?" suggestions, flags unknown filters with suggestions. Stateless and safe for real-time editor use.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create public API barrel and verify end-to-end integration</name>
  <files>
    src/lib/services/templates/index.ts
  </files>
  <action>
Create `src/lib/services/templates/index.ts` as the public API barrel file. This is the ONLY file other modules should import from. No service should ever import from liquidjs directly or from individual template module files.

**Barrel exports (follow codebase barrel pattern from CONVENTIONS.md):**

```typescript
/**
 * Template Engine Module
 *
 * Unified template rendering and validation system using LiquidJS.
 * All services should import from this module -- never from liquidjs directly.
 *
 * Usage:
 *   import { templateEngine, validateTemplate, variableRegistry } from '$lib/services/templates'
 *
 *   // Render a template
 *   const output = templateEngine.render('Hello {{ name }}', { name: 'World' })
 *
 *   // Validate before saving
 *   const result = validateTemplate('Hello {{ name }}')
 *   if (!result.valid) { /* show errors */ }
 *
 *   // Check available variables
 *   const systemVars = variableRegistry.getByCategory('system')
 */
```

Export the following:

1. **From engine.ts:**
   - `templateEngine` singleton instance (the main render entry point)

2. **From validator.ts:**
   - `validateTemplate` function

3. **From variables.ts:**
   - `variableRegistry` singleton instance
   - `SYSTEM_VARIABLES` constant array (for reference/documentation)

4. **From types.ts (type re-exports):**
   - All types: `VariableType`, `VariableCategory`, `VariableDefinition`, `TemplateContext`, `ValidationError`, `ValidationResult`, `RenderResult`

Use the selective export pattern (not `export *`) per codebase conventions. Group exports with comments.

**After creating the barrel file, run a quick integration check:**

Create a temporary script or use node to verify the full pipeline works:
```
// Pseudo-verification (run manually or via node -e)
// 1. render works: templateEngine.render('{{ x }}', { x: 'hello' }) === 'hello'
// 2. conditionals work: templateEngine.render('{% if a %}yes{% endif %}', { a: true }) === 'yes'
// 3. filters work: templateEngine.render('{{ x | upcase }}', { x: 'hi' }) === 'HI'
// 4. validation catches bad syntax: validateTemplate('{% if %}').valid === false
// 5. validation catches unknown var: validateTemplate('{{ unknownXyz }}').valid === false
// 6. validation passes valid template: validateTemplate('{{ protagonistName }}').valid === true
// 7. registry has system vars: variableRegistry.has('protagonistName') === true
```

Do NOT leave the test script in the codebase. This is just for verification.
  </action>
  <verify>
1. `npx tsc --noEmit` passes for the entire project
2. The barrel file exports: templateEngine, validateTemplate, variableRegistry, SYSTEM_VARIABLES, and all type re-exports
3. Run integration verification:
   ```bash
   node -e "
     // Quick smoke test of the full module
     // Note: may need ts-node or compile first depending on project setup
   "
   ```
   If direct node execution isn't possible with TypeScript, verify by:
   - Confirming all imports resolve (tsc --noEmit)
   - Confirming barrel re-exports match actual exports from source files
4. File structure is complete: `ls src/lib/services/templates/` shows types.ts, engine.ts, variables.ts, validator.ts, index.ts
  </verify>
  <done>
index.ts barrel file exports the complete template engine public API. All five files exist in src/lib/services/templates/. TypeScript compilation passes. The module is ready for consumption by Phase 2 (preset packs) and Phase 3 (service integration) via `import { templateEngine, validateTemplate, variableRegistry } from '$lib/services/templates'`.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full Phase 1 engine against roadmap success criteria:

1. **ENG-01 (LiquidJS default config):** engine.ts uses `new Liquid()` with minimal config (strictFilters, strictVariables, jsTruthy only)
2. **ENG-02 (Liquid syntax):** render() handles `{{ variable }}` syntax
3. **ENG-03 (Conditionals):** render() handles `{% if %}{% elsif %}{% else %}{% endif %}`
4. **ENG-04 (Filters):** render() handles `{{ var | filter }}` with 40+ built-in filters
5. **ENG-05 (One pass, one context):** render() takes one template + one context object, returns one string
6. **ENG-06 (Three categories):** variableRegistry has system, runtime, custom categories
7. **ENG-07 (Variable types):** VariableDefinition has type field: text, enum, number, boolean
8. **ENG-08 (Sandboxed):** LiquidJS is inherently safe -- no eval, no code execution. No includes/extends configured.
9. **ENG-09 (Unknown variable feedback):** validateTemplate() reports unknown variables with user-friendly messages and "did you mean?" suggestions
10. **ENG-10 (Circular reference detection):** Per CONTEXT.md and RESEARCH.md: "Variables do not reference other variables -- no expression evaluation, no circular reference risk." The flat TemplateContext type enforces this by design. No implementation needed beyond the type constraint.

**File structure check:**
```
src/lib/services/templates/
  types.ts       -- Type definitions
  engine.ts      -- LiquidJS wrapper (render, parse, extract)
  variables.ts   -- Variable registry (system, runtime, custom)
  validator.ts   -- Validation (syntax + variables + filters)
  index.ts       -- Public API barrel
```
</verification>

<success_criteria>
- validateTemplate() catches syntax errors with user-friendly messages (not raw LiquidJS errors)
- validateTemplate() catches unknown variable references with "did you mean?" suggestions
- validateTemplate() catches unknown filter references with suggestions
- validateTemplate() returns { valid: true, errors: [] } for valid templates with known variables
- index.ts barrel exports templateEngine, validateTemplate, variableRegistry, and all types
- Full TypeScript compilation passes with no errors
- All 10 ENG requirements are addressed by the combined Plan 01 + Plan 02 artifacts
</success_criteria>

<output>
After completion, create `.planning/phases/01-template-engine-foundation/01-02-SUMMARY.md`
</output>
