---
phase: 01-template-engine-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - src/lib/services/templates/types.ts
  - src/lib/services/templates/engine.ts
  - src/lib/services/templates/variables.ts
autonomous: true

must_haves:
  truths:
    - "A template '{{ name }}' renders to the value of name from context"
    - "Templates with {% if x %}...{% elsif %}...{% else %}...{% endif %} conditionals render correctly based on context values"
    - "Templates with built-in filters like {{ name | upcase }} render correctly"
    - "Templates with {% for item in list %}...{% endfor %} loops render correctly"
    - "render() returns a plain string, never throws to the caller"
    - "Unknown variables at render time produce empty string (not error), with console log"
    - "Variables are defined with type (text, enum, number, boolean) and category (system, runtime, custom)"
    - "Variable registry holds all three categories and can look up definitions by name"
  artifacts:
    - path: "src/lib/services/templates/types.ts"
      provides: "VariableType, VariableCategory, VariableDefinition, ValidationResult, ValidationError, TemplateContext types"
      exports: ["VariableType", "VariableCategory", "VariableDefinition", "ValidationResult", "ValidationError", "TemplateContext"]
    - path: "src/lib/services/templates/engine.ts"
      provides: "LiquidJS wrapper with render() and parseTemplate() functions"
      exports: ["templateEngine"]
    - path: "src/lib/services/templates/variables.ts"
      provides: "Variable registry with system, runtime, custom categories"
      exports: ["variableRegistry"]
  key_links:
    - from: "src/lib/services/templates/engine.ts"
      to: "liquidjs"
      via: "import { Liquid } from 'liquidjs'"
      pattern: "import.*Liquid.*from.*liquidjs"
    - from: "src/lib/services/templates/engine.ts"
      to: "src/lib/services/templates/types.ts"
      via: "imports TemplateContext type"
      pattern: "import.*TemplateContext.*from.*types"
    - from: "src/lib/services/templates/variables.ts"
      to: "src/lib/services/templates/types.ts"
      via: "imports VariableDefinition, VariableType, VariableCategory"
      pattern: "import.*VariableDefinition.*from.*types"
---

<objective>
Install LiquidJS, create the type system, build the core template rendering engine, and implement the variable registry with three categories (system, runtime, custom).

Purpose: This is the foundational layer of the new prompt template system. The engine wrapper, type definitions, and variable registry must exist before validation or public API can be built. Everything in Phase 1 (and later phases) depends on these artifacts.

Output: LiquidJS installed, types.ts with all template/variable type definitions, engine.ts wrapping LiquidJS with a safe render function, variables.ts with a registry supporting system/runtime/custom variable definitions.
</objective>

<execution_context>
@C:/Users/Admin/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-template-engine-foundation/01-CONTEXT.md
@.planning/phases/01-template-engine-foundation/01-RESEARCH.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STACK.md
@src/lib/services/prompts/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install LiquidJS and create type definitions</name>
  <files>
    package.json
    package-lock.json
    src/lib/services/templates/types.ts
  </files>
  <action>
1. Install LiquidJS:
   ```
   npm install liquidjs
   ```

2. Create `src/lib/services/templates/types.ts` with the following type definitions. Follow codebase conventions: no semicolons, single quotes, 2-space indent, trailing commas. Use PascalCase for types/interfaces, camelCase for properties.

Define these types:

- `VariableType = 'text' | 'number' | 'boolean' | 'enum'` (ENG-07)
- `VariableCategory = 'system' | 'runtime' | 'custom'` (ENG-06)
- `VariableDefinition` interface with fields:
  - `name: string` -- the variable name used in templates (e.g., 'protagonistName')
  - `type: VariableType`
  - `category: VariableCategory`
  - `description: string` -- human-readable description for non-technical users
  - `required: boolean` -- whether this variable must have a value
  - `defaultValue?: string | number | boolean` -- optional default
  - `enumValues?: string[]` -- available options when type is 'enum'

- `TemplateContext = Record<string, string | number | boolean | string[] | undefined>` -- the flat context object passed to render(). Simple values only, no nested objects, no variable references to other variables.

- `ValidationError` interface:
  - `type: 'syntax' | 'unknown_variable' | 'unknown_filter'`
  - `message: string` -- user-friendly message (non-technical wording)
  - `line?: number`
  - `column?: number`

- `ValidationResult` interface:
  - `valid: boolean`
  - `errors: ValidationError[]`

- `RenderResult` -- for internal use:
  - `output: string`
  - `error?: string` -- only set if render failed (bug scenario per user decision)

Export all types. Keep the file focused: types only, no logic, no imports from external packages.
  </action>
  <verify>
Run `npx tsc --noEmit src/lib/services/templates/types.ts` (or the project-level TypeScript check). Verify:
- File compiles without errors
- LiquidJS is in package.json dependencies
- `node_modules/liquidjs` directory exists
  </verify>
  <done>
LiquidJS installed in package.json. types.ts exports VariableType, VariableCategory, VariableDefinition, TemplateContext, ValidationError, ValidationResult, and RenderResult with correct TypeScript definitions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create template engine wrapper and variable registry</name>
  <files>
    src/lib/services/templates/engine.ts
    src/lib/services/templates/variables.ts
  </files>
  <action>
**engine.ts -- LiquidJS wrapper (ENG-01, ENG-02, ENG-03, ENG-04, ENG-05, ENG-08):**

Create a class `TemplateEngine` that wraps a single LiquidJS `Liquid` instance. Export a singleton `templateEngine`.

Constructor configuration for the Liquid instance:
- `strictFilters: true` -- unknown filters should error (caught in validation, not render)
- `strictVariables: false` -- we handle unknown variables ourselves; at render time we want empty string not error
- `globals: {}` -- no global variables, all passed per-render
- `jsTruthy: true` -- use JavaScript truthiness for conditionals (more intuitive for non-technical users)
- Do NOT configure `root`, `layouts`, `partials`, or `extname` -- templates are standalone, no includes/extends per user decision

Public methods:

1. `render(template: string, context: TemplateContext): string`
   - Calls `this.liquid.parseAndRenderSync(template, context)`
   - Wraps in try/catch. On error: log with `createLogger('TemplateEngine')`, return empty string (per user decision: "Never break the user's experience")
   - This is the one-pass render (ENG-05): one template string + one context object = one output string
   - Returns just a string, nothing more (per user decision: "render() returns just a string")

2. `parseTemplate(template: string): { success: boolean; error?: string }`
   - Calls `this.liquid.parse(template)` to check syntax
   - Returns `{ success: true }` if parse succeeds
   - Returns `{ success: false, error: <message> }` if parse throws
   - This is used by the validator for syntax checking. Do NOT catch errors silently here -- this is the validation path, not the render path.

3. `extractVariableNames(template: string): string[]`
   - Parse the template and walk the AST (LiquidJS parse returns Token[]) to extract all variable names referenced in the template
   - LiquidJS parse returns an array of template tokens. Output tokens (for `{{ var }}`) have a `value` or `name` property. Tag tokens (for `{% if var %}`) contain variable references.
   - For a simpler approach: use a regex pattern `/\{\{[\s]*([a-zA-Z_][\w.]*?)[\s|]*(?:\|[^}]*)?\}\}/g` to extract variable names from output tags, and `/\{%[\s]*(?:if|elsif|unless|for|assign|case|when)[\s]+([a-zA-Z_][\w.]*)/g` for tag variable references.
   - Return deduplicated array of variable name strings.
   - This enables validation of variable references without depending on the variable registry (that dependency lives in validator.ts).

Follow codebase conventions: use `createLogger` from `$lib/services/ai/core/config` (check actual import path -- the codebase uses this pattern in all services). No semicolons, single quotes.

**variables.ts -- Variable registry (ENG-06, ENG-07):**

Create a class `VariableRegistry` that manages variable definitions across three categories. Export a singleton `variableRegistry`.

Internal storage: `Map<string, VariableDefinition>` keyed by variable name.

Public methods:

1. `register(definition: VariableDefinition): void` -- add a variable definition to the registry. Throw if name already registered (prevent duplicates).

2. `registerMany(definitions: VariableDefinition[]): void` -- convenience for bulk registration.

3. `get(name: string): VariableDefinition | undefined` -- look up by name.

4. `has(name: string): boolean` -- check existence.

5. `getByCategory(category: VariableCategory): VariableDefinition[]` -- get all variables in a category.

6. `getAllNames(): string[]` -- return all registered variable names (used by validator to check references).

7. `getAll(): VariableDefinition[]` -- return all registered definitions.

8. `clear(): void` -- remove all definitions (useful for reinitialization).

9. `remove(name: string): void` -- remove a single variable definition.

**Pre-populate with known system variables.** Define a `SYSTEM_VARIABLES` array at module level with the system variables that are auto-filled by the application (these come from the existing PromptContext in the old system). Include at minimum:
- `protagonistName` (text, system, "Name of the main character")
- `currentLocation` (text, system, "Current story location")
- `storyTime` (text, system, "Current in-story time")
- `genre` (text, system, "Story genre")
- `tone` (text, system, "Story tone/mood")
- `settingDescription` (text, system, "World/setting description")
- `themes` (text, system, "Story themes as comma-separated list")
- `mode` (enum, system, "Story mode", enumValues: ['adventure', 'creative-writing'])
- `pov` (enum, system, "Point of view", enumValues: ['first', 'second', 'third'])
- `tense` (enum, system, "Narrative tense", enumValues: ['past', 'present'])

Call `registerMany(SYSTEM_VARIABLES)` in the constructor so the registry starts with system variables pre-loaded.

Do NOT register runtime or custom variables in this file -- those will be registered dynamically by services (Phase 3) and preset packs (Phase 2).
  </action>
  <verify>
1. Run `npx tsc --noEmit` on the project to verify both files compile.
2. Manually verify in engine.ts:
   - `import { Liquid } from 'liquidjs'` is present
   - `parseAndRenderSync` is called (synchronous rendering)
   - try/catch wraps render with empty string return on error
   - `strictVariables: false` in Liquid config
   - `strictFilters: true` in Liquid config
3. Manually verify in variables.ts:
   - SYSTEM_VARIABLES array has at least 10 entries
   - `registerMany(SYSTEM_VARIABLES)` called in constructor
   - All methods exist and use the Map correctly
  </verify>
  <done>
engine.ts exports a `templateEngine` singleton with render(), parseTemplate(), and extractVariableNames() methods. render() returns a string, catches errors silently at render time. variables.ts exports a `variableRegistry` singleton pre-loaded with system variables covering all known auto-filled context values (protagonistName, genre, tone, mode, pov, tense, etc.).
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the foundation works end-to-end:

1. **Types compile:** `npx tsc --noEmit` passes with no errors in any templates/ file
2. **LiquidJS installed:** `node -e "const { Liquid } = require('liquidjs'); console.log('OK')"` prints OK
3. **Engine renders:** Create a quick inline test:
   ```
   node -e "
     const { Liquid } = require('liquidjs');
     const l = new Liquid({ strictVariables: false, strictFilters: true, jsTruthy: true });
     console.log(l.parseAndRenderSync('Hello {{ name }}', { name: 'World' }));
     console.log(l.parseAndRenderSync('{% if show %}visible{% else %}hidden{% endif %}', { show: true }));
     console.log(l.parseAndRenderSync('{{ name | upcase }}', { name: 'test' }));
   "
   ```
   Expected: "Hello World", "visible", "TEST"
4. **File structure:** `src/lib/services/templates/` contains types.ts, engine.ts, variables.ts
</verification>

<success_criteria>
- LiquidJS is installed and importable
- types.ts defines all variable and validation types (VariableType, VariableCategory, VariableDefinition, TemplateContext, ValidationError, ValidationResult)
- engine.ts wraps LiquidJS with safe render (empty string on error), parseTemplate (for validation), and extractVariableNames
- variables.ts provides a registry pre-loaded with 10+ system variables across text and enum types
- All files follow codebase conventions (no semicolons, single quotes, PascalCase types, camelCase methods)
- No references to old prompt system (clean slate)
</success_criteria>

<output>
After completion, create `.planning/phases/01-template-engine-foundation/01-01-SUMMARY.md`
</output>
