---
phase: 02-preset-pack-system
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - src/lib/services/packs/pack-service.ts
  - src/lib/services/packs/validation.ts
  - src/lib/services/packs/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Default pack is automatically seeded with all PROMPT_TEMPLATES on first app launch"
    - "New templates added in app updates are automatically added to the default pack"
    - "Creating a new pack copies all templates and variables from the default pack"
    - "Any template can be checked for modification against the default baseline via hash comparison"
    - "Any template can be reset to the default baseline content"
    - "Default pack cannot be deleted; packs with stories assigned cannot be deleted"
    - "Pack data is validated with Zod schemas at creation and import boundaries"
    - "Public API barrel exports all pack functionality from a single import path"
  artifacts:
    - path: "src/lib/services/packs/pack-service.ts"
      provides: "PackService class with initialize, createPack, deletePack, isTemplateModified, resetTemplate methods"
      min_lines: 120
    - path: "src/lib/services/packs/validation.ts"
      provides: "Zod schemas and validatePackImport function"
      contains: "PackExportSchema"
    - path: "src/lib/services/packs/index.ts"
      provides: "Public API barrel exporting packService, validation, and types"
      min_lines: 15
  key_links:
    - from: "src/lib/services/packs/pack-service.ts"
      to: "src/lib/services/database.ts"
      via: "database singleton import for all CRUD operations"
      pattern: "import.*database.*from.*services/database"
    - from: "src/lib/services/packs/pack-service.ts"
      to: "src/lib/services/prompts/templates/index.ts"
      via: "PROMPT_TEMPLATES import for default content seeding"
      pattern: "import.*PROMPT_TEMPLATES.*from.*prompts/templates"
    - from: "src/lib/services/packs/validation.ts"
      to: "src/lib/services/packs/types.ts"
      via: "Zod schemas mirror TypeScript interfaces"
      pattern: "z\\.object"
---

<objective>
Build the pack service layer with business logic, validation, and public API.

Purpose: Provide the business logic layer that orchestrates pack operations -- initializing the default pack, creating new packs, checking modification status, resetting templates, and validating pack data. Also installs Zod and creates validation schemas for Phase 5 import/export readiness.

Output: PackService class, Zod validation schemas, and public API barrel file.
</objective>

<execution_context>
@C:/Users/Admin/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-preset-pack-system/02-CONTEXT.md
@.planning/phases/02-preset-pack-system/02-RESEARCH.md
@.planning/codebase/CONVENTIONS.md

# Prior plan summaries for what was built
@.planning/phases/02-preset-pack-system/02-01-SUMMARY.md
@.planning/phases/02-preset-pack-system/02-02-SUMMARY.md

# Types and database methods created by prior plans
@src/lib/services/packs/types.ts
@src/lib/services/database.ts

# PROMPT_TEMPLATES source of truth
@src/lib/services/prompts/templates/index.ts
@src/lib/services/prompts/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Zod and create pack service with validation</name>
  <files>src/lib/services/packs/pack-service.ts, src/lib/services/packs/validation.ts</files>
  <action>
**Step 1: Install Zod**

Run `npm install zod` to add the validation library.

**Step 2: Create validation schemas (src/lib/services/packs/validation.ts)**

Create `src/lib/services/packs/validation.ts` with Zod schemas for pack data validation. Follow codebase conventions (no semicolons, single quotes, trailing commas).

```typescript
import { z } from 'zod'

/**
 * Zod schemas for preset pack validation.
 * Used at system boundaries: pack creation, import/export.
 * NOT used for every database read (trust database integrity after validated writes).
 */

/** Valid Liquid variable name pattern: lowercase letters, numbers, underscores, must start with letter or underscore */
const variableNameRegex = /^[a-z_][a-z0-9_]*$/

/** Enum option: label for display, value for storage */
export const EnumOptionSchema = z.object({
  label: z.string().min(1),
  value: z.string().min(1),
})

/** Custom variable definition within a pack */
export const CustomVariableSchema = z.object({
  variableName: z.string().min(1).regex(variableNameRegex, {
    message: 'Variable name must use lowercase letters, numbers, and underscores only',
  }),
  displayName: z.string().min(1),
  variableType: z.enum(['text', 'textarea', 'enum', 'number', 'boolean']),
  isRequired: z.boolean(),
  defaultValue: z.string().optional(),
  enumOptions: z.array(EnumOptionSchema).optional(),
}).refine(
  (data) => {
    // Enum type must have at least one option
    if (data.variableType === 'enum') {
      return data.enumOptions && data.enumOptions.length > 0
    }
    return true
  },
  { message: 'Enum variables must have at least one option' },
)

/** Pack template: template ID + content */
export const PackTemplateSchema = z.object({
  templateId: z.string().min(1),
  content: z.string(),
})

/** Full pack export schema (versioned for Phase 5 forward compatibility) */
export const PackExportSchema = z.object({
  version: z.literal(1),
  name: z.string().min(1),
  description: z.string().optional(),
  author: z.string().optional(),
  templates: z.array(PackTemplateSchema),
  variables: z.array(CustomVariableSchema),
})

/** Type inferred from export schema */
export type PackExport = z.infer<typeof PackExportSchema>

/**
 * Validate pack import data.
 * Returns structured result with either valid pack data or human-readable error messages.
 */
export function validatePackImport(data: unknown): {
  valid: boolean
  errors?: string[]
  pack?: PackExport
} {
  const result = PackExportSchema.safeParse(data)
  if (result.success) {
    return { valid: true, pack: result.data }
  }
  return {
    valid: false,
    errors: result.error.errors.map(e => `${e.path.join('.')}: ${e.message}`),
  }
}

/**
 * Validate a single custom variable definition.
 * Used when creating/editing variables in the UI (Phase 4).
 */
export function validateCustomVariable(data: unknown): {
  valid: boolean
  errors?: string[]
} {
  const result = CustomVariableSchema.safeParse(data)
  if (result.success) {
    return { valid: true }
  }
  return {
    valid: false,
    errors: result.error.errors.map(e => `${e.path.join('.')}: ${e.message}`),
  }
}
```

**Step 3: Create pack service (src/lib/services/packs/pack-service.ts)**

Create `src/lib/services/packs/pack-service.ts` with the PackService class. Follow codebase conventions.

```typescript
import { database } from '$lib/services/database'
import { PROMPT_TEMPLATES } from '$lib/services/prompts/templates'
import type { PresetPack, FullPack, PackTemplate } from './types'

/**
 * Pack Service
 *
 * Business logic for preset pack management.
 * Handles default pack initialization, pack creation (copies from default),
 * template modification detection, and safe pack deletion.
 *
 * All database operations are delegated to DatabaseService.
 * This service adds the business rules on top.
 */
class PackService {
  private initialized = false

  /**
   * Initialize the pack system.
   * Call on app startup after database is ready.
   * - Ensures default pack exists
   * - Seeds templates from PROMPT_TEMPLATES if missing
   * - Adds any new templates from app updates
   * Idempotent: safe to call multiple times.
   */
  async initialize(): Promise<void> {
    if (this.initialized) return

    let defaultPack = await database.getDefaultPack()

    if (!defaultPack) {
      // Create default pack if missing (first run)
      defaultPack = await database.createPack({
        id: 'default-pack',
        name: 'Default',
        description: 'Built-in prompt templates shipped with Aventura',
        author: 'Aventura',
        isDefault: true,
      })
    }

    // Check existing templates
    const existingTemplates = await database.getPackTemplates('default-pack')
    const existingIds = new Set(existingTemplates.map(t => t.templateId))

    // Seed or update templates from PROMPT_TEMPLATES
    for (const template of PROMPT_TEMPLATES) {
      // Seed system prompt content
      if (!existingIds.has(template.id)) {
        await database.setPackTemplateContent('default-pack', template.id, template.content)
      }
      // Seed user content (if template has it)
      const userContentId = `${template.id}-user`
      if (template.userContent && !existingIds.has(userContentId)) {
        await database.setPackTemplateContent('default-pack', userContentId, template.userContent)
      }
    }

    this.initialized = true
  }

  /**
   * Get all preset packs.
   */
  async getAllPacks(): Promise<PresetPack[]> {
    return database.getAllPacks()
  }

  /**
   * Get a single pack by ID.
   */
  async getPack(id: string): Promise<PresetPack | null> {
    return database.getPack(id)
  }

  /**
   * Load a pack with all its templates and variables.
   */
  async getFullPack(packId: string): Promise<FullPack | null> {
    const pack = await database.getPack(packId)
    if (!pack) return null

    const [templates, variables] = await Promise.all([
      database.getPackTemplates(packId),
      database.getPackVariables(packId),
    ])

    return { pack, templates, variables }
  }

  /**
   * Create a new pack by copying all templates and variables from the default pack.
   * Per user decision: new packs start as a copy of the default pack.
   */
  async createPack(name: string, description?: string, author?: string): Promise<PresetPack> {
    const packId = crypto.randomUUID()

    // Create pack metadata
    const pack = await database.createPack({
      id: packId,
      name,
      description: description ?? null,
      author: author ?? null,
      isDefault: false,
    })

    // Copy all templates from default pack
    const defaultTemplates = await database.getPackTemplates('default-pack')
    for (const template of defaultTemplates) {
      await database.setPackTemplateContent(packId, template.templateId, template.content)
    }

    // Copy all variables from default pack
    const defaultVariables = await database.getPackVariables('default-pack')
    for (const variable of defaultVariables) {
      await database.createPackVariable(packId, {
        variableName: variable.variableName,
        displayName: variable.displayName,
        variableType: variable.variableType,
        isRequired: variable.isRequired,
        defaultValue: variable.defaultValue,
        enumOptions: variable.enumOptions,
      })
    }

    return pack
  }

  /**
   * Delete a pack if allowed.
   * Per user decisions:
   * - Default pack cannot be deleted
   * - Pack cannot be deleted while any story uses it
   * Returns true if deleted, false if not allowed.
   */
  async deletePack(packId: string): Promise<{ deleted: boolean, reason?: string }> {
    const pack = await database.getPack(packId)
    if (!pack) return { deleted: false, reason: 'Pack not found' }
    if (pack.isDefault) return { deleted: false, reason: 'Cannot delete the default pack' }

    const canDelete = await database.canDeletePack(packId)
    if (!canDelete) {
      return { deleted: false, reason: 'Pack is in use by one or more stories. Reassign stories first.' }
    }

    await database.deletePack(packId)
    return { deleted: true }
  }

  /**
   * Check if a template in a pack has been modified from the default baseline.
   * Compares the pack template's content hash against the hash of the default content.
   */
  async isTemplateModified(packId: string, templateId: string): Promise<boolean> {
    const packTemplate = await database.getPackTemplate(packId, templateId)
    if (!packTemplate) return false

    // Find default baseline content
    const defaultContent = this.getDefaultContent(templateId)
    if (defaultContent === null) return false

    const defaultHash = await this.hashContent(defaultContent)
    return packTemplate.contentHash !== defaultHash
  }

  /**
   * Get modification status for all templates in a pack.
   * Returns a map of templateId -> isModified.
   */
  async getModifiedTemplates(packId: string): Promise<Map<string, boolean>> {
    const templates = await database.getPackTemplates(packId)
    const result = new Map<string, boolean>()

    for (const template of templates) {
      const defaultContent = this.getDefaultContent(template.templateId)
      if (defaultContent === null) {
        result.set(template.templateId, false)
        continue
      }
      const defaultHash = await this.hashContent(defaultContent)
      result.set(template.templateId, template.contentHash !== defaultHash)
    }

    return result
  }

  /**
   * Reset a template to the default baseline content.
   * Per user decision: reset is per-template, not per-pack.
   */
  async resetTemplate(packId: string, templateId: string): Promise<boolean> {
    const defaultContent = this.getDefaultContent(templateId)
    if (defaultContent === null) return false

    await database.setPackTemplateContent(packId, templateId, defaultContent)
    return true
  }

  /**
   * Get the default baseline content for a template ID.
   * Handles both system prompt (template.id) and user message (template.id + '-user') patterns.
   */
  private getDefaultContent(templateId: string): string | null {
    // Check for user content template (e.g., 'adventure-user')
    if (templateId.endsWith('-user')) {
      const baseId = templateId.replace(/-user$/, '')
      const template = PROMPT_TEMPLATES.find(t => t.id === baseId)
      return template?.userContent ?? null
    }

    // System prompt content
    const template = PROMPT_TEMPLATES.find(t => t.id === templateId)
    return template?.content ?? null
  }

  /**
   * Hash content using SHA-256 with whitespace normalization.
   * Duplicates DatabaseService.hashContent intentionally -- service layer
   * needs hashing for comparison without going through the database.
   */
  private async hashContent(content: string): Promise<string> {
    const normalized = content.trim().replace(/\r\n/g, '\n')
    const encoder = new TextEncoder()
    const data = encoder.encode(normalized)
    const hashBuffer = await crypto.subtle.digest('SHA-256', data)
    const hashArray = Array.from(new Uint8Array(hashBuffer))
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')
  }
}

/** Singleton pack service instance */
export const packService = new PackService()
```

Key design decisions:
- Singleton pattern matches existing services (database, templateEngine)
- `initialize()` is idempotent and called on app startup
- Template seeding handles both `content` and `userContent` from PROMPT_TEMPLATES (41 templates, ~35 with userContent = ~76 pack_templates rows)
- User content uses `templateId-user` naming convention (matches existing PromptOverride pattern)
- hashContent is duplicated from DatabaseService intentionally -- service layer needs it for comparison without database round-trips
- deletePack returns structured result with reason (better UX than throwing)
  </action>
  <verify>Run `npm install zod` first. Then `npx svelte-check` to confirm everything compiles. Verify pack-service.ts exports `packService` singleton. Verify validation.ts exports `validatePackImport`, `validateCustomVariable`, `PackExportSchema`, `CustomVariableSchema`.</verify>
  <done>PackService handles all pack business logic (initialization, creation, deletion, modification detection, reset). Zod validation schemas are ready for Phase 5 import/export. Both files compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create public API barrel for packs module</name>
  <files>src/lib/services/packs/index.ts</files>
  <action>
Create `src/lib/services/packs/index.ts` as the public API barrel file. Follow the same pattern as `src/lib/services/templates/index.ts` (selective exports, grouped with comments, JSDoc at top).

```typescript
/**
 * Preset Pack Module
 *
 * Storage and management infrastructure for preset packs.
 * A pack bundles all prompt templates and custom variable definitions into a single unit.
 *
 * @example
 * import { packService, validatePackImport } from '$lib/services/packs'
 *
 * // Initialize on app startup
 * await packService.initialize()
 *
 * // Create a new pack
 * const pack = await packService.createPack('My Custom Pack', 'Custom prompts', 'User')
 *
 * // Check if template modified
 * const isModified = await packService.isTemplateModified(pack.id, 'adventure')
 *
 * // Validate import data
 * const result = validatePackImport(jsonData)
 */

// ============================================================================
// Pack Service
// ============================================================================

export { packService } from './pack-service'

// ============================================================================
// Validation
// ============================================================================

export {
  validatePackImport,
  validateCustomVariable,
  PackExportSchema,
  CustomVariableSchema,
  EnumOptionSchema,
  PackTemplateSchema,
} from './validation'

// ============================================================================
// Type Exports
// ============================================================================

export type {
  PresetPack,
  PackTemplate,
  CustomVariable,
  CustomVariableType,
  EnumOption,
  FullPack,
} from './types'

export type { PackExport } from './validation'
```

This barrel provides a single import point: `$lib/services/packs`. All consumers (Phase 3 context system, Phase 4 UI, Phase 5 import/export) will import from here.
  </action>
  <verify>Run `npx svelte-check` to confirm the barrel file compiles and all re-exports resolve correctly. Verify that importing from `$lib/services/packs` provides access to packService, validatePackImport, and all type exports.</verify>
  <done>Public API barrel exports packService, validation functions, Zod schemas, and all type definitions from a single import path ($lib/services/packs).</done>
</task>

</tasks>

<verification>
- [ ] Zod is installed (check package.json for "zod" dependency)
- [ ] validation.ts defines schemas for EnumOption, CustomVariable, PackTemplate, PackExport
- [ ] CustomVariableSchema validates variableName regex (lowercase, underscores only)
- [ ] CustomVariableSchema enforces enum type must have at least one option
- [ ] PackExportSchema has version: z.literal(1) for forward compatibility
- [ ] validatePackImport returns structured result with human-readable errors
- [ ] validateCustomVariable validates single variable definitions
- [ ] pack-service.ts exports packService singleton
- [ ] initialize() creates default pack if missing, seeds templates from PROMPT_TEMPLATES
- [ ] initialize() handles both content and userContent template seeding
- [ ] initialize() adds new templates from app updates (idempotent)
- [ ] createPack() copies all templates and variables from default pack
- [ ] deletePack() prevents default pack deletion and in-use pack deletion
- [ ] isTemplateModified() compares pack hash against default baseline hash
- [ ] getModifiedTemplates() returns modification status for all templates in a pack
- [ ] resetTemplate() restores default content for a specific template
- [ ] getDefaultContent() handles both 'templateId' and 'templateId-user' patterns
- [ ] index.ts barrel exports packService, validation functions, schemas, and all types
- [ ] TypeScript compilation passes (svelte-check)
</verification>

<success_criteria>
Complete pack management system is operational. Default pack seeding works from PROMPT_TEMPLATES. New packs can be created as copies of default. Template modification detection and reset work via hash comparison. Pack deletion is guarded by business rules. Validation schemas are ready for Phase 5. Everything is accessible from `$lib/services/packs`.
</success_criteria>

<output>
After completion, create `.planning/phases/02-preset-pack-system/02-03-SUMMARY.md`
</output>
