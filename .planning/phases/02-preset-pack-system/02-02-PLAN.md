---
phase: 02-preset-pack-system
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/services/database.ts
autonomous: true

must_haves:
  truths:
    - "Pack CRUD operations work through DatabaseService following established patterns"
    - "Pack templates can be queried, upserted, and deleted per pack"
    - "Pack variables can be queried, created, updated, and deleted per pack"
    - "canDeletePack returns false when stories reference the pack"
    - "Content hashing uses SHA-256 via Web Crypto API with whitespace normalization"
  artifacts:
    - path: "src/lib/services/database.ts"
      provides: "Pack CRUD methods, template operations, variable operations, deletion safety check, content hashing"
      contains: "getAllPacks"
  key_links:
    - from: "src/lib/services/database.ts"
      to: "src/lib/services/packs/types.ts"
      via: "import type for PresetPack, PackTemplate, CustomVariable, EnumOption"
      pattern: "import type.*PresetPack.*from.*packs/types"
    - from: "src/lib/services/database.ts"
      to: "src-tauri/migrations/025_preset_packs.sql"
      via: "SQL queries match migration schema columns"
      pattern: "preset_packs|pack_templates|pack_variables"
---

<objective>
Add pack database operations to the existing DatabaseService.

Purpose: Provide the data access layer for preset packs by extending DatabaseService with CRUD methods for packs, pack templates, and pack variables. This follows the established repository pattern already used for stories, characters, vault items, etc.

Output: Extended database.ts with all pack-related query methods and mapper functions.
</objective>

<execution_context>
@C:/Users/Admin/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-preset-pack-system/02-CONTEXT.md
@.planning/phases/02-preset-pack-system/02-RESEARCH.md
@.planning/codebase/CONVENTIONS.md

# Plan 01 summary for types created
@.planning/phases/02-preset-pack-system/02-01-SUMMARY.md

# Types this plan imports
@src/lib/services/packs/types.ts

# File being extended (read fully before modifying)
@src/lib/services/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pack CRUD and template operations to DatabaseService</name>
  <files>src/lib/services/database.ts</files>
  <action>
Read `src/lib/services/database.ts` fully before modifying. This file is ~2600 lines. Add pack-related methods and imports.

**Step 1: Add imports at top of file**

Add type imports from the pack types module (follow existing import pattern):
```typescript
import type {
  PresetPack,
  PackTemplate,
  CustomVariable,
  EnumOption,
} from '$lib/services/packs/types'
```

**Step 2: Add content hashing utility method**

Add a private method to the DatabaseService class for SHA-256 content hashing. Place it near the other private helper methods (around line 1776+ where mapper functions start):

```typescript
/**
 * Hash template content using SHA-256 for modification detection.
 * Normalizes whitespace before hashing to prevent false positives.
 */
private async hashContent(content: string): Promise<string> {
  const normalized = content.trim().replace(/\r\n/g, '\n')
  const encoder = new TextEncoder()
  const data = encoder.encode(normalized)
  const hashBuffer = await crypto.subtle.digest('SHA-256', data)
  const hashArray = Array.from(new Uint8Array(hashBuffer))
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')
}
```

**Step 3: Add pack CRUD methods**

Add these methods to DatabaseService class after the existing vault methods (before the private mapper functions section). Follow established patterns exactly (getDb(), select/execute, mapper functions):

```typescript
// ===== Preset Pack Operations =====

async getAllPacks(): Promise<PresetPack[]> {
  const db = await this.getDb()
  const results = await db.select<any[]>('SELECT * FROM preset_packs ORDER BY is_default DESC, name ASC')
  return results.map(this.mapPack)
}

async getPack(id: string): Promise<PresetPack | null> {
  const db = await this.getDb()
  const results = await db.select<any[]>('SELECT * FROM preset_packs WHERE id = ?', [id])
  return results.length > 0 ? this.mapPack(results[0]) : null
}

async getDefaultPack(): Promise<PresetPack | null> {
  const db = await this.getDb()
  const results = await db.select<any[]>('SELECT * FROM preset_packs WHERE is_default = 1 LIMIT 1')
  return results.length > 0 ? this.mapPack(results[0]) : null
}

async createPack(pack: Omit<PresetPack, 'createdAt' | 'updatedAt'>): Promise<PresetPack> {
  const db = await this.getDb()
  const now = Date.now()
  await db.execute(
    'INSERT INTO preset_packs (id, name, description, author, is_default, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?)',
    [pack.id, pack.name, pack.description, pack.author, pack.isDefault ? 1 : 0, now, now],
  )
  return { ...pack, createdAt: now, updatedAt: now }
}

async updatePack(id: string, updates: { name?: string, description?: string | null, author?: string | null }): Promise<void> {
  const db = await this.getDb()
  const now = Date.now()
  const setClauses: string[] = ['updated_at = ?']
  const values: any[] = [now]

  if (updates.name !== undefined) {
    setClauses.push('name = ?')
    values.push(updates.name)
  }
  if (updates.description !== undefined) {
    setClauses.push('description = ?')
    values.push(updates.description)
  }
  if (updates.author !== undefined) {
    setClauses.push('author = ?')
    values.push(updates.author)
  }

  values.push(id)
  await db.execute(`UPDATE preset_packs SET ${setClauses.join(', ')} WHERE id = ?`, values)
}

async deletePack(id: string): Promise<void> {
  const db = await this.getDb()
  await db.execute('DELETE FROM preset_packs WHERE id = ? AND is_default = 0', [id])
}

async canDeletePack(packId: string): Promise<boolean> {
  const db = await this.getDb()
  // Cannot delete default pack
  const pack = await this.getPack(packId)
  if (!pack || pack.isDefault) return false
  // Cannot delete if stories reference it
  const results = await db.select<any[]>(
    'SELECT COUNT(*) as count FROM stories WHERE pack_id = ?',
    [packId],
  )
  return results[0].count === 0
}
```

**Step 4: Add pack template operations**

```typescript
// ===== Pack Template Operations =====

async getPackTemplates(packId: string): Promise<PackTemplate[]> {
  const db = await this.getDb()
  const results = await db.select<any[]>(
    'SELECT * FROM pack_templates WHERE pack_id = ? ORDER BY template_id',
    [packId],
  )
  return results.map(this.mapPackTemplate)
}

async getPackTemplate(packId: string, templateId: string): Promise<PackTemplate | null> {
  const db = await this.getDb()
  const results = await db.select<any[]>(
    'SELECT * FROM pack_templates WHERE pack_id = ? AND template_id = ?',
    [packId, templateId],
  )
  return results.length > 0 ? this.mapPackTemplate(results[0]) : null
}

async setPackTemplateContent(packId: string, templateId: string, content: string): Promise<void> {
  const db = await this.getDb()
  const now = Date.now()
  const contentHash = await this.hashContent(content)
  // Use INSERT OR REPLACE to handle both create and update
  // Need to preserve original created_at if exists
  const existing = await this.getPackTemplate(packId, templateId)
  const createdAt = existing ? existing.createdAt : now
  await db.execute(
    `INSERT OR REPLACE INTO pack_templates (id, pack_id, template_id, content, content_hash, created_at, updated_at)
     VALUES (?, ?, ?, ?, ?, ?, ?)`,
    [existing?.id ?? crypto.randomUUID(), packId, templateId, content, contentHash, createdAt, now],
  )
}

async deletePackTemplate(packId: string, templateId: string): Promise<void> {
  const db = await this.getDb()
  await db.execute(
    'DELETE FROM pack_templates WHERE pack_id = ? AND template_id = ?',
    [packId, templateId],
  )
}
```

**Step 5: Add pack variable operations**

```typescript
// ===== Pack Variable Operations =====

async getPackVariables(packId: string): Promise<CustomVariable[]> {
  const db = await this.getDb()
  const results = await db.select<any[]>(
    'SELECT * FROM pack_variables WHERE pack_id = ? ORDER BY variable_name',
    [packId],
  )
  return results.map(this.mapPackVariable)
}

async getPackVariable(packId: string, variableName: string): Promise<CustomVariable | null> {
  const db = await this.getDb()
  const results = await db.select<any[]>(
    'SELECT * FROM pack_variables WHERE pack_id = ? AND variable_name = ?',
    [packId, variableName],
  )
  return results.length > 0 ? this.mapPackVariable(results[0]) : null
}

async createPackVariable(packId: string, variable: Omit<CustomVariable, 'id' | 'packId' | 'createdAt'>): Promise<CustomVariable> {
  const db = await this.getDb()
  const id = crypto.randomUUID()
  const now = Date.now()
  await db.execute(
    `INSERT INTO pack_variables (id, pack_id, variable_name, display_name, variable_type, is_required, default_value, enum_options, created_at)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    [
      id,
      packId,
      variable.variableName,
      variable.displayName,
      variable.variableType,
      variable.isRequired ? 1 : 0,
      variable.defaultValue ?? null,
      variable.enumOptions ? JSON.stringify(variable.enumOptions) : null,
      now,
    ],
  )
  return { id, packId, ...variable, createdAt: now }
}

async updatePackVariable(id: string, updates: Partial<Omit<CustomVariable, 'id' | 'packId' | 'createdAt'>>): Promise<void> {
  const db = await this.getDb()
  const setClauses: string[] = []
  const values: any[] = []

  if (updates.variableName !== undefined) {
    setClauses.push('variable_name = ?')
    values.push(updates.variableName)
  }
  if (updates.displayName !== undefined) {
    setClauses.push('display_name = ?')
    values.push(updates.displayName)
  }
  if (updates.variableType !== undefined) {
    setClauses.push('variable_type = ?')
    values.push(updates.variableType)
  }
  if (updates.isRequired !== undefined) {
    setClauses.push('is_required = ?')
    values.push(updates.isRequired ? 1 : 0)
  }
  if (updates.defaultValue !== undefined) {
    setClauses.push('default_value = ?')
    values.push(updates.defaultValue)
  }
  if (updates.enumOptions !== undefined) {
    setClauses.push('enum_options = ?')
    values.push(updates.enumOptions ? JSON.stringify(updates.enumOptions) : null)
  }

  if (setClauses.length === 0) return

  values.push(id)
  await db.execute(`UPDATE pack_variables SET ${setClauses.join(', ')} WHERE id = ?`, values)
}

async deletePackVariable(id: string): Promise<void> {
  const db = await this.getDb()
  await db.execute('DELETE FROM pack_variables WHERE id = ?', [id])
}

// ===== Story-Pack Assignment =====

async getStoryPackId(storyId: string): Promise<string | null> {
  const db = await this.getDb()
  const results = await db.select<any[]>('SELECT pack_id FROM stories WHERE id = ?', [storyId])
  return results.length > 0 ? results[0].pack_id : null
}

async setStoryPack(storyId: string, packId: string): Promise<void> {
  const db = await this.getDb()
  await db.execute('UPDATE stories SET pack_id = ? WHERE id = ?', [packId, storyId])
}
```

**Step 6: Add mapper functions**

Add these private mapper functions alongside the existing mappers (after the existing mapVaultScenario or at the end of the private mapper section):

```typescript
private mapPack(row: any): PresetPack {
  return {
    id: row.id,
    name: row.name,
    description: row.description,
    author: row.author,
    isDefault: row.is_default === 1,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  }
}

private mapPackTemplate(row: any): PackTemplate {
  return {
    id: row.id,
    packId: row.pack_id,
    templateId: row.template_id,
    content: row.content,
    contentHash: row.content_hash,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  }
}

private mapPackVariable(row: any): CustomVariable {
  return {
    id: row.id,
    packId: row.pack_id,
    variableName: row.variable_name,
    displayName: row.display_name,
    variableType: row.variable_type,
    isRequired: row.is_required === 1,
    defaultValue: row.default_value ?? undefined,
    enumOptions: row.enum_options ? JSON.parse(row.enum_options) : undefined,
    createdAt: row.created_at,
  }
}
```

IMPORTANT:
- Follow existing code style exactly: no semicolons, single quotes, trailing commas, 2-space indent
- Use `any[]` for db.select generic parameter (matches existing pattern)
- Use `any[]` for values arrays (matches existing pattern)
- Boolean to integer conversion (isDefault ? 1 : 0) matches existing patterns
- JSON.parse guard for nullable enum_options (row.enum_options ? JSON.parse(...) : undefined) matches existing pattern
- hashContent uses the Web Crypto API (crypto.subtle.digest) which is available in both browser and Tauri contexts
  </action>
  <verify>Run `npx svelte-check` to confirm TypeScript compilation passes with the new imports and methods. Verify the file contains all new method names: getAllPacks, getPack, getDefaultPack, createPack, updatePack, deletePack, canDeletePack, getPackTemplates, getPackTemplate, setPackTemplateContent, deletePackTemplate, getPackVariables, getPackVariable, createPackVariable, updatePackVariable, deletePackVariable, getStoryPackId, setStoryPack, hashContent, mapPack, mapPackTemplate, mapPackVariable.</verify>
  <done>DatabaseService has complete CRUD operations for packs, pack templates, and pack variables, plus story-pack assignment and content hashing. All methods follow established patterns. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Add PRAGMA foreign_keys enforcement to database init</name>
  <files>src/lib/services/database.ts</files>
  <action>
The existing DatabaseService.init() method does NOT enable foreign key enforcement (confirmed by codebase search). SQLite foreign keys are disabled by default. Without this, ON DELETE RESTRICT on stories.pack_id will NOT be enforced.

Modify the `init()` method in DatabaseService to enable foreign keys after loading the database:

```typescript
async init(): Promise<void> {
  if (this.db) return
  this.db = await Database.load('sqlite:aventura.db')
  // Enable foreign key enforcement (SQLite disables by default)
  await this.db.execute('PRAGMA foreign_keys = ON')
}
```

Add `await this.db.execute('PRAGMA foreign_keys = ON')` as the last line in init(), after the Database.load() call. This is critical for pack deletion safety -- without it, deleting a pack that stories reference will silently succeed instead of throwing an error.

Do NOT change anything else in init().
  </action>
  <verify>Search database.ts for "PRAGMA foreign_keys" to confirm it was added. Run `npx svelte-check` to confirm no regressions.</verify>
  <done>Foreign key enforcement is enabled on database initialization, ensuring pack deletion constraints work correctly.</done>
</task>

</tasks>

<verification>
- [ ] database.ts imports PresetPack, PackTemplate, CustomVariable, EnumOption from packs/types
- [ ] getAllPacks, getPack, getDefaultPack, createPack, updatePack, deletePack methods exist
- [ ] canDeletePack checks both isDefault and story references
- [ ] deletePack includes `AND is_default = 0` guard
- [ ] getPackTemplates, getPackTemplate, setPackTemplateContent, deletePackTemplate methods exist
- [ ] setPackTemplateContent uses hashContent for content_hash
- [ ] setPackTemplateContent preserves original created_at on update
- [ ] getPackVariables, getPackVariable, createPackVariable, updatePackVariable, deletePackVariable methods exist
- [ ] createPackVariable serializes enumOptions as JSON
- [ ] mapPackVariable deserializes enum_options with null guard
- [ ] getStoryPackId and setStoryPack methods exist
- [ ] hashContent normalizes whitespace before hashing
- [ ] PRAGMA foreign_keys = ON is in init() method
- [ ] TypeScript compilation passes (svelte-check)
</verification>

<success_criteria>
DatabaseService provides complete data access layer for preset packs. All CRUD operations for packs, templates, and variables work. Foreign key enforcement is enabled. Content hashing normalizes whitespace. All methods follow established DatabaseService patterns exactly.
</success_criteria>

<output>
After completion, create `.planning/phases/02-preset-pack-system/02-02-SUMMARY.md`
</output>
